BPF (Berkeley Package Filter) as it was originally presented is a system for effective filtering of network packages by allowing dynamical loading of package filters from userspace into the network stack in kernel space.
The extended Berkeley Packet Filter (eBPF) was later introduced in the Linux kernel, offering a different approach to kernel extension.
The eBPF virtual machine leverages the privileges of the kernel to oversee the entire system, enabling more powerful control.
the eBPF name furthermore refers to a just-in-time (JIT) compiled reduced instruction set computer (RISC). The ecosystem seeks to ensure security by performing static analysis of the limited language.
This language is designed not to be turing complete,
to reduce the number of rejected programs due to limitations in the static analysis.
In eBPF there are 11 registers, r0-r10, where r0 is used for return values of functions and r10 is a readonly framepointer to a 512 byte stack.
Instructions can be moves, addition and jumps in a similar manner to other reduced instructions sets.


The eBPF program loading process is presented in Figure \ref{fig:loader}.
First step in the process involves obtaining a program using an abstraction tool such as BCC\cite{BCC} or libbpf\cite{libbpf} or writing the program by hand in C macros.
The ~bpf~ syscall is then invoked and the eBPF bytecode is moved into the kernel.
The verifier then performs a series of security measures that determines if a program is allowed for loading or rejected.
The security measures involves static analysis in the form of abstract interpretation using tristate numbers, cycle detection,
division by zero, and more.
We describe this in detail in Section \ref{sec:verifier}.
If a program is determined safe by the verifier, the program is loaded into the kernel, either for interpretation or JIT-compiled depending on the kernel configurations. The program is then attached to a hook.

#+CAPTION: eBPF loading process \cite{loader}
#+NAME:   fig:laoder
[[./Background/loader.png]]


eBPF programs are event-driven, meaning they can be attached to a certain hook, and every time the corresponding event occurs, the program is triggered.
For example, a program can be attached to a socket, and every time something is written to this socket, the program is triggered.
Although an eBPF program lives in kernel space, it conceptually resides somewhere between user and kernel space.
It can interact with both the kernel and user space through a collection of key-value stores called maps, realized as a variety of different data structures such as ring buffers, arrays, etc.
These data structures also reside in kernel space and are constructed through the ~bpf~ syscall, allowing eBPF programs to read and write to a map. Users can also read and write to the maps using the ~bpf~ syscall, thus serving as a communication layer between eBPF program and user space.

eBPF programs should likewise not been seen as a coherent part of the kernel as it cannot call kernel functions directly.
The reason for this is that eBPF is designed to be kernel version agnostic\cite{helpers}, and linux kernels functions are not stable.
In reality it is not agnostic since different versions of the verifier will reject and accept different programs.
Instead, the eBPF subsystem provides a stable API of helper functions to provide functionality not immediately accessible in the limited instruction set.
Furthermore it is possible to have eBPF programs call other eBPF programs, and even chain them together in tail calls similar to
standard function calls, greatly extending the functionality of eBPF programs.

This subsystem hence serves an opportunity for users to extend the kernel with functionality that may not break the system while still leveraging the powers of the kernel. Unfortunately due to bugs in the verifier, most major Linux distributions such as Ubuntu, Fedora, Redhat and many more, disallow non-root users to load eBPF programs.

** Spelunking the eBPF verifier
:PROPERTIES:
:CUSTOM_ID: sec:verifier
:END:
In this section we describe in detail how an eBPF program is loaded. We first describe, how the ~bpf~ syscall is defined and we then proceed to give a general understanding of what steps is taken in the process of loading an eBPF program.
Specifically what requirements the programs must follow and how this is realized.

*** The bpf syscall
All interaction between user and kernel space regarding eBPF related matter uses the bpf syscall\footnote{bpf() has syscall number 321} and has the following signature:

#+begin_src c
asmlinkage long
sys_bpf(int cmd, union bpf_attr *attr, unsigned int size);
#+end_src

Argument ~cmd~ is an integer that defines the intended interaction, for the purpose of this project we only care about the cmd ~BPF_PROG_LOAD~, but intentions such as ~BPF_MAP_UPDATE_ELEM~, ~BPF_MAP_CREATE~ and ~BPF_MAP_LOOKUP_ELEM~ also exists.

To be able to load an eBPF program one of the following criteria must be met:
- Either a the caller of the syscall must be root or be bpf capable,
- or the ~kernel.unprivileged_bpf_disabled~ kernel parameter must be set to 0, meaning regular users are capable of loading programs. As mentioned previously for security reasons this is disabled in most major Linux distributions.

The ~attr~ argument is a union of structures that must correspond to the argument type.
For program loading this stuct notably contains the type of program to load, which could be socket programs, kernel probes, Express Data Path or one of the many other possibilities.
The syscall will call the appropriate ~cmd~ after some sanity checks, such as wellformedness of the ~bpf_attr~ union with respect to the command and the ~size~ parameter.
The first function called is ~bpf_prog_load~.

*** Capabilities and Kernel configurations: ~bfp_prog_load~
The main purpose of ~bfp_prog_load~ is to check for user capabilities and setting the parameters used in the verifier based on
kernel configurations. It checks the following:
1. normal users may only load socket programs, whilst network related programs such as XDP requires network capabilities or system administrator capabilities and performance monitoring of hardware requires perfmon capabilities.
2. only ~bpf_capable~ users may use unaligned memory access in eBPF maps.
3. eBPF programs must be between 1 and 4096 instructions. For capable users the limit is 1 million instructions.
4. The license of the program is checked and programs with gpl capabilities may call helper functions with GPL licence.
5. Then programs may be either eBPF programs or BTF objects, which is typelevel information about eBPF programs.
   These are mainly used as debug information about eBPF program and they are irrelevant to the verifier and thus also the work done in this report.
6. The program is checked for device boundness, as eBPF programs can be offloaded to devices.

These are all properties of an eBPF program must still be checked even if the verifier is not present.
In the design of a new loading procedure ~bpf_prog_load~ should be mostly kept in tact.
We would however still need to modify the call to ~bpf_check~ as this is the entrypoint to the verifier.

*** Static analysis: ~bpf_check~
The ~bpf_check~ is what we usually denotes as the verifier.
Firstly the checking environment is setup. The environment is a big struct with all necessary information to complete the
validation.
The procedure starts by checking more capabilities, for instance we have the following lines:
#+begin_src c
env->allow_ptr_leaks = bpf_allow_ptr_leaks();
env->allow_uninit_stack = bpf_allow_uninit_stack();
env->bypass_spec_v1 = bpf_bypass_spec_v1();
env->bypass_spec_v4 = bpf_bypass_spec_v4();
env->bpf_capable = bpf_capable();
#+end_src
The first 4 is flags only set for perfmon capabilities, which allow perfmon capable users to do more with the eBPF stack.
Environment variables such as these, introduce a dilemma in terms of what can be removed from the verifier. We describe this more in detail in Section \ref{design}.

After these initial flags, the function does the follow checks:

a. Firstly eBPF subprograms and kernel helper functions are added to the environment, Notice here, that the main subprogram is also considered a subprogram, so whenever we state subprograms are checked this correponds to the main as well as all helper functions etc.
b. Then function ~check_subprogs~ is called, where some simple checks are conduncted, such as subprograms not being allowed to jump outside of its own address space. The last instruction of a subprogram must either exit or jump.
   Interestingly enough a jump at the end should in general not be allowed since we may not jump backwards, and we may not jump out of the subprogram. I am not entirely sure what is going on in this specific case.
c. If the eBPF program is device bound, it is prepared for this. Again we omit the detail as we have not looked into the specific details of the device offloaded.
d. Next ~bpf_check~ will check the control flow graph for loops, by a non-recursive depth first search approach. If a cycle is detected, the program is rejected.
e. all the subprograms are then check according to their BPF TypeFormat (BTF)
f. The last step before loading a program is abstract interpretation using tri-state numbers (~tnum~) happens.

The following is a simplification of the kernel documentation about the verifier\cite{kernelverifier}.
A program must follow these requirements:
e. Registers may not be read unless they have previously been written. This is to ensure no kernel memory can be leaked.
f. Registers can either be scalars or pointers. After calls to kernel functions or when a subprogram ends, registers r1-r5 is forgotten and thus cannot be read before written. r6-r9 is callee saved and thus still available.
g. Reading and writing may only be done by registers marked by ~ptr_to_ctx~, ~ptr_to_stack~ or ~ptr_to_map~.
   These are bound and alignment checked.
- Stack space, for same reason as registers, may not be read before it has been written.
- External calls are checked at entry to make sure the registers are appropriate wrt. the external function.
- All read and writes to the stack and maps should be within bounds.
- Division by 0 is not allowed, unless the divisor is a register in which case the program is patched later in the verification process.

To keep track of this the verifier will do abstract interpretation. The verification process tracks
minimum and maximum values in both the signed and unsigned domain.
It furthermore use ~tnums~ which is a pair of a mask and a value.
The mask tracks bits that are unknown.
Set bits in the value are known to be 1.
The program is then traversed and updated modulo the instructions.
For instance if register ~r2~ is a scalar and known to be in the range between ~(0,IMAX)~ then after abstractly interpreting a conditional jump ~r2 > 42~ the current state is split in two and the state where the condition is taken now have an updated range of ~42 <= r2<= IMAX~ etc.
Pointers are handled in a similar manner, however since pointer arithmetic is inherently dangerous, modifying a pointer is very limited in eBPF.
Additionally pointers may be interpreted as different types of pointers and are check wrt. the program type they occur in. For instance ~BPF_MAP_TYPE_SOCKMAP~ may only be used with socket type programs.


After abstract interpretation, the stack depth is checked, meaning we simply check if the function calls can fit within the stack space allocated for the eBPF program.

Next dead code is eliminated. The argumentation in the comments for the implementation are questionable.
Specifically they mention that malicious code can have dead code too, which clearly is correct, but also completely irrelevant.
Especially since they are turned into ~JA -1~ instructions.

If all these requirements are met, then an eBPF program is loaded.
This mapping of cause is simplified a lot, but it shows that the current process of checking a valid
eBPF program has many step of which some are directly code specific and some are tied to intentions and capabilities.
