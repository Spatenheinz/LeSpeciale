In this section, we describe in detail how an eBPF program is loaded.
We first describe, how the ~bpf~ syscall is defined and we then proceed to give a general understanding of what steps are taken in the process of loading an eBPF program.
Specifically, it is important what requirements the programs must follow and how this is realized.

*** The bpf syscall
All interaction between user and kernel space regarding eBPF-related matter uses the bpf syscall\footnote{bpf() has syscall number 321} and has the following signature:

#+begin_src c
asmlinkage long
sys_bpf(int cmd, union bpf_attr *attr, unsigned int size);
#+end_src

Argument ~cmd~ is an integer that defines the intended interaction. For the purpose of this project, we only care about the cmd ~BPF_PROG_LOAD~, but intentions such as ~BPF_MAP_UPDATE_ELEM~, ~BPF_MAP_CREATE~ and ~BPF_MAP_LOOKUP_ELEM~ also exists.

To be able to load an eBPF program one of the following criteria must be met:
- Either the caller of the syscall must be root or be bpf capable,
- or the ~kernel.unprivileged_bpf_disabled~ kernel parameter must be set to 0, meaning regular users are capable of loading programs. As mentioned previously for security reasons this is disabled in most major Linux distributions.

The ~attr~ argument is a union of structures that must correspond to the argument type.
For program loading, ~attr~ notably contains the type of program to load, which could be socket programs, kernel probes, Express Data Path, or one of the many other possibilities, as well as the program that needs to be loaded.
The syscall will call the appropriate ~cmd~ after some sanity checks, such as the well-formedness of the ~bpf_attr~ union w.r.t the command and the ~size~ parameter.
The first function called is ~bpf_prog_load~.

*** Capabilities and Kernel configurations: ~bfp_prog_load~
The main purpose of ~bfp_prog_load~ is to check for user capabilities and setting the parameters used in the verifier based on
kernel configurations. It checks the following:
1. Normal users may only load socket programs, whilst network-related eBPF programs such as XDP requires network or system administrator capabilities. For performance monitoring the user loading the program must have perfmon capabilities.
2. Only ~bpf_capable~ users may use unaligned memory access in eBPF maps.
3. eBPF programs must be between 1 and 4096 instructions. For capable users, the limit is 1 million instructions.
4. The license of the program is checked and programs with GPL capabilities may call helper functions with GPL license.
5. Programs may be either eBPF programs or BTF objects, which is type-level information about eBPF programs.
   These are mainly used as debug information about eBPF programs and they are irrelevant to the verifier, thus also the work done in this report.
6. The program is checked for device boundness, as eBPF programs can be offloaded to devices.

These are all properties of an eBPF program, and must still be checked even if the verifier is not present.
In the design of a new loading procedure ~bpf_prog_load~ should be mostly kept intact.
We would however still need to modify the call to ~bpf_check~ as this is the entry point to the verifier.

*** Static analysis: ~bpf_check~
The ~bpf_check~ is what we usually denote as the verifier.
Firstly the checking environment is set up. The environment is a big struct with all the necessary information to complete the
validation.
The procedure starts by checking more capabilities, for instance, we have the following lines:
#+begin_src c
env->allow_ptr_leaks = bpf_allow_ptr_leaks();
env->allow_uninit_stack = bpf_allow_uninit_stack();
env->bypass_spec_v1 = bpf_bypass_spec_v1();
env->bypass_spec_v4 = bpf_bypass_spec_v4();
env->bpf_capable = bpf_capable();
#+end_src
The first 4 are flags only set for perfmon capabilities, which allow perfmon capable users to do more with the eBPF stack.
Environment variables such as these introduce a dilemma in terms of what can be removed from the verifier. This is discussed in \ref{sec:certifications}.

After these initial flags, the function does the following checks:

a. Firstly eBPF subprograms and kernel helper functions are added to the environment. Notice here, that the main eBPF program is also considered a subprogram, so whenever we state subprograms are checked this corresponds to the main as the eBPF subprograms.
b. Then function ~check_subprogs~ is called, where some simple checks are conducted, such as subprograms not being allowed to jump outside of their own address space. The last instruction of a subprogram must either exit or jump to a subprogram, constituting a tail call.
c. If the eBPF program is supposed to be device bound, it is prepared for that. We omit the details as we have not taken the device offloaded into account for this project. But it is an additional factor to consider in the replacement of the verifier.
d. Next ~bpf_check~ will check the control flow graph for loops using a non-recursive depth-first search approach. If a cycle is detected, the program is rejected.
e. All the subprograms are then checked according to their BPF TypeFormat (BTF).
f. The last step before loading a program is abstract interpretation using tri-state numbers (~tnum~).

The following is a simplification of the kernel documentation about the verifier\cite{kernelverifier}.
A program must follow these requirements:
e. Registers may not be read unless they have previously been written. This is to ensure no kernel memory can be leaked.
f. Registers can either be scalars or pointers. After calls to kernel functions or when a subprogram ends, registers r1-r5 are forgotten and thus cannot be read before written. r6-r9 are callee saved and thus still available.
g. Reading and writing may only be done by registers marked by ~ptr_to_ctx~, ~ptr_to_stack~, or ~ptr_to_map~.
   These are bound and alignment checked.
- Stack space, for the same reason as registers, may not be read before it has been written.
- External calls are checked at entry to make sure the registers are appropriate w.r.t. the external functions.
- All read and writes to the stack and maps should be within bounds.
- Division by 0 is not allowed unless the divisor is a register in which case the program is patched later in the verification process.

To keep track of this the verifier will do abstract interpretation. The verification process tracks
minimum and maximum values in both the signed and unsigned domain.
It furthermore uses ~tnums~ which is a pair of a mask and a value.
The mask tracks unknown bits.
Set bits in the value are known to be 1.
The program is then traversed and updated modulo the instructions.
For instance if register ~r2~ is a scalar and known to be in the range between ~(0, IMAX)~ then after abstractly interpreting a conditional jump ~r2 > 42~ the current state is split in two and the state where the condition is taken now have an updated range of ~42 <= r2<= IMAX~.
Pointers are handled similarly, however since pointer arithmetic is inherently dangerous, modifying a pointer is very limited in eBPF.
Additionally, pointers may be interpreted as different types of pointers and are checked wrt. the program type they occur in. For instance ~BPF_MAP_TYPE_SOCKMAP~ may only be used with socket-type programs.


After abstract interpretation, the stack depth is checked, meaning we simply check if the function calls can fit within the stack space allocated for the eBPF program.

Next dead code is eliminated. The argumentation in the comments for the implementation is questionable.
Specifically, they mention that malicious code can have dead code too, which clearly is correct, but also completely irrelevant.
Especially since they are turned into ~JA -1~ instructions.

If all these requirements are met, then an eBPF program is loaded.
This mapping is simplified a lot, but it shows that the current process of checking a valid
eBPF program has many steps of which some are directly code specific and some are tied to intentions and capabilities.
This makes a PCC system a little more difficult to realize.
