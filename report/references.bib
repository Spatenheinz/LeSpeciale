@online{manfred,
  author = {Manfred Paul},
  title = {{CVE-2020-8835:} Linux Kernel Privilege Escalation via Improper eBPF Program Verification},
  year = 2020,
  url = {https://www.zerodayinitiative.com/blog/2020/4/8/cve-2020-8835-linux-kernel-privilege-escalation-via-improper-ebpf-program-verification},
  urldate = {2023-05-25}
}
@online{scanell,
  author = {Simon Scanell},
  title = {Fuzzing for eBPF JIT bugs in the Linux kernel},
  year = 2021,
  url = {https://scannell.io/posts/ebpf-fuzzing/},
  urldate = {2023-05-23}
}
@inproceedings{pcc,
author = {Necula, George C.},
title = {Proof-Carrying Code},
year = {1997},
isbn = {0897918533},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/263699.263712},
doi = {10.1145/263699.263712},
abstract = {This paper describes proof-carrying code (PCC), a mechanism by which a host system can determine with certainty that it is safe to execute a program supplied (possibly in binary form) by an untrusted source. For this to be possible, the untrusted code producer must supply with the code a safety proof that attests to the code's adherence to a previously defined safety policy. The host can then easily and quickly validate the proof without using cryptography and without consulting any external agents.In order to gain preliminary experience with PCC, we have performed several case studies. We show in this paper how proof-carrying code might be used to develop safe assembly-language extensions of ML programs. In the context of this case study, we present and prove the adequacy of concrete representations for the safety policy, the safety proofs, and the proof validation. Finally, we briefly discuss how we use proof-carrying code to develop network packet filters that are faster than similar filters developed using other techniques and are formally guaranteed to be safe with respect to a given operating system safety policy.},
booktitle = {Proceedings of the 24th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {106–119},
numpages = {14},
location = {Paris, France},
series = {POPL '97}
}
@article{lfsc,
author = {Stump, Aaron and Oe, Duckki and Reynolds, Andrew and Hadarean, Liana and Tinelli, Cesare},
year = {2013},
month = {02},
pages = {},
title = {SMT Proof Checking Using a Logical Framework},
volume = {42},
journal = {Formal Methods in System Design},
doi = {10.1007/s10703-012-0163-3}
}
@online{BCC,
  title = {BPF Compiler Collection (BCC)},
  url = {https://github.com/iovisor/bcc},
  urldate = {2023-05-26}}

@online{libbpf,
  title = {libbpf},
  url = {https://github.com/libbpf/libbpf},
  urldate = {2023-05-26}}
@online{loader,
  title = {Loading process of ePBF programs},
  url = {https://ebpf.io/static/7eec5ccd8f6fbaf055256da4910acd5a/b5f15/loader.png},
  urldate = {2023-05-26}}
@online{helpers,
  title = {eBPF Helper calls},
  url = {https://ebpf.io/what-is-ebpf/#helper-calls},
  urldate = {2023-05-26}}
@article{lf,
author = {Harper, Robert and Honsell, Furio and Plotkin, Gordon},
title = {A Framework for Defining Logics},
year = {1993},
issue_date = {Jan. 1993},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {40},
number = {1},
issn = {0004-5411},
url = {https://doi.org/10.1145/138027.138060},
doi = {10.1145/138027.138060},
abstract = {The Edinburgh Logical Framework (LF) provides a means to define (or present) logics. It is based on a general treatment of syntax, rules, and proofs by means of a typed λ-calculus with dependent types. Syntax is treated in a style similar to, but more general than, Martin-Lo¨f's system of arities. The treatment of rules and proofs focuses on his notion of a judgment. Logics are represented in LF via a new principle, the judgments as types principle, whereby each judgment is identified with the type of its proofs. This allows for a smooth treatment of discharge and variable occurence conditions and leads to a uniform treatment of rules and proofs whereby rules are viewed as proofs of higher-order judgments and proof checking is reduced to type checking. The practical benefit of our treatment of formal systems is that logic-independent tools, such as proof editors and proof checkers, can be constructed.},
journal = {J. ACM},
month = {jan},
pages = {143–184},
numpages = {42},
keywords = {interactive theorem proving, typed lambda calculus, formal systems, proof checking}
}
@INPROCEEDINGS{nbe,

  author={Berger, U. and Schwichtenberg, H.},

  booktitle={[1991] Proceedings Sixth Annual IEEE Symposium on Logic in Computer Science},

  title={An inverse of the evaluation functional for typed lambda -calculus},

  year={1991},

  volume={},

  number={},

  pages={203-211},

  doi={10.1109/LICS.1991.151645}}
@report{nbehs,
author = {David Thrane Christiansen},
title = {Checking Dependent Types with Normalization by Evaluation: A Tutorial (Haskell Version)},
year = {2019}}
@online{lfscsigs,
  title = {LFSC signatures},
  url = {https://github.com/cvc5/cvc5/tree/main/proofs/lfsc/signatures},
  urldate = {2023-05-28}}
