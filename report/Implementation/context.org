Signatures \Sigma is denoted as ~GlobalContext~ while \Gamma is used for the ~LocalContext~.
They have a similar interface but internally works quite differently.
A global context is defined as such:
#+begin_src rust
pub struct GlobalContext<'term, K: BuiltIn> {
    kvs: HashMap<K, TypeEntry<'term, K>>
}
#+end_src
The only field of the struct is a ~Hashmap~ with key-value pairs.
We only define it as a hashmap because the implementation does not live in the kernel.
For a version compatible with the kernel, we would use a ~Vec~ or implement a hashmap that works in the kernel.
In any case, the interface is the same.

A type entry is defined as:
#+begin_src rust
pub enum TypeEntry<'term, Key: BuiltIn>
{
    Def { ty: RT<'term, Key>, val: RT<'term, Key> },
    IsA { ty: RT<'term, Key>, },
    Val { val: RT<'term, Key> },
}
#+end_src
Notice here that this does not directly correspond to our definition in \ref{sec:signatures}.
- The ~IsA~ construct corresponds directly to \(x : A\), while the other two are defined purely for ease of use.
- The ~Def~ constructor is used for definitions stating that a constant /c/ is a term /M/ with type /A/. We mainly use this for top-level definition aswell as type inference of let bindings.
- The ~Val~ is used in extending the environment in evaluation. This constructor can never occur in \Sigma but may occur in $\Gamma$.
  Having this constructor allow us to reuse $\Gamma$ for evaluation.

The global context exposes the following functions:
#+begin_src rust
pub fn insert(&self, key: K, ty: RT<'term, K>)
pub fn define(&self, name: K, ty: RT<'term, K>, val: RT<'term, K>)
pub fn get_value(&self, key: &K) -> ResRT<'term, K>
pub fn get_type(&self, key: &K) -> ResRT<'term, K>
#+end_src
If one tries to get the value of a ~IsA~ type,
they get a neutral expression consisting of the stored type ~ty~ and a neutral symbol of the key.
On the other hand if one tries to get the type of ~Val~ then an error occurs.

The local context exposes a much similar interface but with a different underlying datastructure.
The local context is implemented as a linked list using reference counted pointers and much more closely
represent the concatenation of \Gamma presented in \ref{sec:signatures}.
#+begin_src rust
pub enum LocalContext<'a, K: BuiltIn> {
    Nil,
    Cons(TypeEntry<'a, K>, Rlctx<'a, K>),
}
#+end_src

Most functions we use such as ~eval~, ~infer~ etc, needs to have access to both \Sigma and \Gamma and thus for simplicity we define the following wrapper.
#+begin_src rust
struct EnvWrapper<'global, 'term, T: Copy> {
    pub lctx: Rlctx<'term, T>,
    pub gctx: Rgctx<'global, 'term, T>,
    pub allow_dbi: u32,
}
#+end_src
Here ~Rlctx~ is a type synonym for a reference counted \Gamma. Whereas ~Rgctx~ is a standard reference to \Sigma, with lifetime ~'global~.
