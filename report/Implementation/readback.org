Reification or reading back semantical objects into the term language is type-directed.
~read_back~ takes a type and a value as arguments.
First, the term to be read back is checked to be neutral, and if that is the case then we call ~read_back_neutral~ since ~Neutral~'s encode their own type. Figure \ref{fig:readbackneu} shows the ~read_back_neutral~ function.

Variables can be read back directly. Holes either get read back as their inner value or as a term language hole.
The application will read back the function point and the argument point, and construct an application from it.
Be aware here that the argument point is a ~Normal~ type. It will thus call ~read_back~ with its type and val.
#+begin_export latex
\begin{figure}[h!]
\begin{lstlisting}
fn readback_neutral(&self, neu: Rc<Neutral<'term, T>>)
                    -> TResult<AlphaTerm<T>, T>
{
    match neu.borrow() {
        Neutral::DBI(i) => Ok(Ident(DBI(*i))),
        Neutral::Var(name) => Ok(Ident(Symbol(*name))),
        Neutral::Hole(hol) => {
            if let Some(ty) = &*hol.borrow() {
                self.readback_neutral(ty.clone())
            } else { Ok(Hole) }
        },
        Neutral::App(f, a) => {
            let f = self.readback_neutral(f.clone())?;
            let a = self.readback_normal(a.clone())?;
            Ok(App(Box::new(f), vec![a]))
        },
    }
}
\end{lstlisting}
\caption{Reification of neutral terms}
\label{fig:readbackneu}
\end{figure}
#+end_export
#+begin_src rust
#+end_src

If the value of ~read_back~ is not neutral we pattern-match on the type.
If the type is \mathcal{Z} or \mathcal{Q} then we can read back integers and rationals respectively.
All built-in types can be read back to the built-in terms.
~Pi~ types can be read back by reading back the domain, then evaluating the body and reading the body back.
