Because of the design decisions described above we immediately get a complication with the concrete syntax.
Proofs generated by CVC5 will follow the concrete syntax, but we need a representation using De Bruijn indices.
Therefore we propose an approach to loading proofs as seen in Figure \ref{fig:dataflow}.
The proof is constructed by an external SMT solver, such as CVC5.
We then have 3 programs in userspace:
1. A parser, that reads the concrete syntax.
2. A converter for translating the concrete syntax into a De Bruijn representation.
3. A transformer that will transform the De Bruijn representation into a format the kernel can read.

Then we also have another parser in kernel space, which read the appropriate format for the type checker.

#+caption: Data flow diagram of sending and processing a proof in the kernel.
#+name: fig:dataflow
#+ATTR_LATEX: :width 0.7\linewidth
[[./Implementation/image.png]]

For the prototyping done in this project, we do not strictly follow this pipeline, as the implementation is still user space specific, but the different components are available, except for the in-kernel parser.
Ideally, data transferred from the userspace into the kernel should be in a zero-copy serializable format.
From the general investigation into what crate can be compiled in the kernel, we have not found any of the major crates for zero-copy to work out of the box, such as ~Cap_N_Proto~ and ~Rkyv~.

*** Abstract Syntax in Rust
#+include: ast.org

*** Parsing LFSC
#+include: parsing.org

*** Converting terms
:PROPERTIES:
:CUSTOM_ID: sec:converter
:END:
#+include: convertion.org
