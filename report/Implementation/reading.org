Because of the design decisions taken above we immediately, get a complication with the concrete syntax.
Proofs generated by CVC5 will follow the concrete syntax, but we need a representation using De Bruijn indices.
Therefore We propose an approach to loading proofs as seen in Figure \ref{fig:dataflow}.
The proof is constructed by an external SMT solver, such as cvc5.
We then have 3 programs in userspace:
1. A parser, that reads the concrete syntax.
2. A converter for translating the concrete syntax into a De Bruijn representation.
3. A transformer which will transform the De Bruijn representation into a format the kernel can read.

Then we have another parser in kernel space, which read the appropriate format for the typechecker.

#+caption: Data flow diagram of sending and processing a proof in the kernel.
#+name: fig:dataflow
[[./Implementation/image.png]]

For the prototyping we have done in this report we have not completely followed this pipeline, as the implementation still is userspace specific. But the different parts are available, except for the in-kernel parser.
Ideally the data transfered from the userspace into the kernel should be in a zero copy serializable format.
From the general investigation into what crate can be compiled in the kernel, we have not found any of the major crates for zero copy to work out of the box, such as ~Cap_N_Proto~ and ~Rkyv~.

*** Abstract Syntax in Rust
#+include: ast.org

*** Parsing LFSC
#+include: parsing.org

*** Converting terms
:PROPERTIES:
:CUSTOM_ID: sec:converter
:END:
#+include: convertion.org
