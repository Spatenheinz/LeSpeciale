* TODO [0/2] Certification of programs
As mentioned in section\ref{} the code producer must hand over code in the appropriate format,
as well as the certificate, so we must consider an appropriate format for the certificate.
The process of checking the certificate should also be both fast and simple.
I consider a PCC architecture which uses Verification condition generation on the eBPF
most likely by using a derivation of Hoare Logic, since this propose an automatic way of
generating formulas, which describes programs.\footnote{should i go more indepth with this?}
The process of proving the validity of such a verification condition however is not a simple task
and is, dependending on the logic,  undecidable.
We will therefore require the code consumer to rely on the process of making this proof and then present
the proof to the kernel.
Checking the satisfiability of a formula can be done by a Satisfiability Modulo Theories (SMT) solver.
In many SMT solvers it is possible to extract a proof that a certain formula is satisfiable.
I have in this work considered two output formats/languages, Alethe and Logical Framework with Side Conditions (LFSC),
supported by the CVC5 SMT solver.
I will briefly describe why I have chosen to use the LFSC language over Alethe.
Both formats follow the LISP family of languages and is therefore simple to parse.
Alethe is designed to be easily readable by humans and is strutured as a box style proof.\footnote{example?}
This is not a property necessary for a PCC architecture where we want to automate the entire process.
By this construction the Alethe format provides a set of basic inference rules of which there are 91\cite{}
on which proofs are built, for instance rule 20 denotes reflexivity often denoted as ~refl~ which describes syntactical
equality between two terms modulo renaming of bound variables.
This entails that an implementation must implement all rules necessary for a security policy and will thne not be easily extended
in the future. LFSC on the otherhand is a metaframework that exploits the Curry-Howard isomorphism, explained in \ref{}.
This metaframework allows for the security policy to be established by signatures, which can easily be extended.
This is very much a property of interest, as eBPF might evolve to support new datastructures etc.
Furthermore this approach can move bugs out of the in kernel certifier and into the specification.
This will enable system administrators to quickly deploy fixes for a bug, by not allowing specific faulty signatures.
It is hard to consider both time and memory used of the two languages, without actually implementing both of them.
But if we consider the amount of code require for the two formats then there exists a rust implementation for an Alethe proof checker, called carcara\cite{}.
This implementation is ~13500 lines of code, and this specific implementation does not even support all theories present in CVC5, such as bitvectors.
LFSC has a proof checker written in C++ and its code is merely 5000 lines, while the signatures may be arbitrarily large.
The solution I present is ~3000 lines.
CVC5 provides some signatures constituting <1500 lines.
Hence LFSC seems like a better choice for an in kernel proof checker.

** TODO Curry-Howard Isormorphism

** TODO Logical Framework with Side Conditions
LFSC is a extention of the Edinbourgh Logical Framework (LF)\cite{} and is a predicative typed lambda calculus with dependent types. This allow proof systems to be encoded as signatures, which amounts to a set of typing declarations. LFSC extends LF by including sideconditions. In this context sideconditions is a operational semantic which might be evaluated during typechecking.
I will in the following section describe the calculus and its typing along with the operational semantic of sideconditions.

*** Syntax
The syntax has 5 categories. At its core LFSC is a typed lambda calculus,
so it consists of terms/objects, types and kinds.
Terms are denoted by M, N and O.
Types are denoted by A and B and used for classification of Terms.
Kinds are denoted by K and is used to classify types.
I use ~x~ to be a metavariable ranging over the set of variables that might occur in terms,
~c~ to denote constants in terms (free variables).
~a~ will range over constants in types.
Sideconditions is denoted by S and T.
Patterns describes pattern in side condition match cases and is denoted by P.
I write keywords in *bold*.
I write [M_1/x_1,...,M_n/x_n]N, for simultanious substitution of ~M_1~, ~M_2 ,..~ with free ocurrences of ~x_1~, ~x_2 ~,... in N. We assume renaming, to avoid name clashing.
I use * to denote a hole.

Figure \ref{} shows the syntactical categories.
TODO: make the figure.

Terms maybe be either a constant ~c~,
a variable ~x~,
a type annotation ~M : A~ stating that term M must have type ~A~,
an abstraction \lambda ~x [:M] . N~, which binds the term M to ~x~ in ~N~,
and lastly a term might be an application of term M to N, notice that application in terms is left-associative, so M N O is (M N) O.

Types may be a type constant ~a~,
an application of a type to a term, ~A M~.
a lambda abstraction ...,
or a dependent product type. Pi types may contain sidecondtions in their binders.

Kinds may be either the *type* which classifies types or they may be a pi type.

Sideconditions may be:
1) an unbounded number, which may be either an integer or a rational.
2) a variable ~x~
3) a *let* binding, setting ~x~ to ~S~ in ~T~.
4) an application. Notice that we require that functions are fully applied and thus non-associative,
sideconditions may then also be one of the categories Compounds, Numerical and Sideeffects.

Compound sideconditions may be either a *fail* ~A~, which raises an exception with type ~A~,
*match* expressions, which will match the scrutinee against patterns and evaluate corrsponding ~S_i~ in a similar manner to ML.
*ifequal* compares ~S~ and ~T~ for syntactical equality.

Numerical sideconditions may be the binary operation addition, multiplication and division,
these follow standard conventions.
It may be a negation, a convertion from integer to rational or it may be one of the two
branching constructs.

Sideeffects may be *ifmarked* a branch based on the marking of a varible. markvar which marks a variable, *do* S T, which is equivalent to *let* ~x~ = ~S~ ~T~ where ~x~ does not occur in ~T~.

Patterns may be either a constructor applied to 0 or more arguments, but the constructor must always be fully applied.

*** Signatures and Contexts
TODO: add signatures.
In LFSC there is two construct we use to keep track of variables and constants. We have signatures, and contexts. Signatures are used to assign kinds and types to constants. This is what the metaframework revolves around.
Contexts are used to assign types to variables.
we write them as such and use \Sigma, \Sigma' to denote the concatenation of the two signatures \Sigma and \Sigma' and similarly for contexts.
#+begin_export latex
\begin{align*}
\Sigma \; ::=& \; \lra{} \mid \Sigma,a : K \mid \Sigma,c : A \\
\Gamma \; ::=& \; \lra{} \mid \Gamma, x: A\\
\end{align*}
#+end_export
The typesystem of LFSC is syntax directed meaning there we have only a single typing rule for each syntactical object.
We achieve this by bidirectional typing.
That means instead of stating that an expression must have a type,
we can either construct a type from it (called inference)
or we can check that an expression has a type.
#+begin_export latex
\begin{align*}
\Sigma \ \checked & \qquad (\Sigma\ \text{is a valid signature})\\
\vdash_\Sigma \ \Gamma & \qquad (\Gamma\ \text{is a valid context in} \ \Sigma)\\
\Gamma \ \vdash_\Sigma K & \qquad (K \ \text{is a kind in \(\Gamma\) and \(\Sigma\)})\\
\Gamma \ \vdash_\Sigma M \Leftarrow A & \qquad (M \ \text{can be checked to have type \(A\) in \(\Gamma\) and \(\Sigma\)})\\
\Gamma \ \vdash_\Sigma M \Rightarrow A & \qquad (M \ \text{can be synthesized to have type \(A\) in \(\Gamma\) and \(\Sigma\)})\\
\end{align*}
#+end_export

Valid signatures:
#+begin_export latex
\begin{figure}[h!]
\begin{equation*}
\inference[EMPTY-SIG ]{}
{\lra{} \ \checked}
\end{equation*}
\begin{equation*}
\inference[KIND-SIG ]{\Sigma \ \checked & \vdashs K & a \notin dom(\Sigma)}
{\Sigma, a: K \ \checked}
\end{equation*}
\begin{equation*}
\inference[TYPE-SIG ]{\Sigma \ \checked & \vdashs A : K & c \notin dom(\Sigma)}
{\Sigma, c: A \ \checked}
\end{equation*}
\caption{Valid signatures}
\end{figure}
#+end_export

Valid contexts:
#+begin_export latex
\begin{figure}[h!]
\begin{equation*}
\inference[EMPTY-CTX ]{\Sigma \ \checked}
{\vdashs \lra{}}
\end{equation*}
\begin{equation*}
\inference[TYPE-CTX ]{\vdashs \Gamma & \Gamma \vdashs A: Type & x \notin dom(\Sigma)}
{\vdashs \Gamma, x: A}
\end{equation*}
\caption{Valid contexts}
\end{figure}
#+end_export

*** Typing
#+begin_export latex
\begin{figure}[h!]
\begin{equation*}
\inference[TYPE ]{\vdash \Gamma}
{\context \mathbf{type} \Rightarrow \mathbf{kind}}
\qquad
\inference[TYPEc ]{\vdash \Gamma}
{\context \mathbf{type}^c \Rightarrow \mathbf{kind}}
\end{equation*}

\begin{equation*}
\inference[LOOKUP-CTX ]{\vdash \Gamma & x: A \in \Gamma}
{\context \synth{x}{A} }
\end{equation*}

\begin{equation*}
\inference[LOOKUP-KIND-SIG ]{\vdash \Gamma & a: K \in \Sigma}
{\context \synth{a}{K} }
\qquad
\inference[LOOKUP-TYPE-SIG ]{\vdash \Gamma & c: A \in \Sigma}
{\context \synth{c}{A} }
\end{equation*}
\caption{Typing rules for looking up types.}
\end{figure}
#+end_export

#+begin_export latex
\begin{figure}[h!]
\begin{equation*}
\inference[ANN ]{\context \tycheck{M}{A} }
{\context \synth{M : A}{A} }
\end{equation*}

\begin{equation*}
\inference[PI ]{\context \tycheck{A}{\mathbf{type}} & \contextcons{x : A} \synth{B}{\alpha} & \alpha \in \{ \mathbf{type}, \mathbf{type^c}, \mathbf{kind} \}  }
{\context \synth{\Pi x : A. \ B}{\alpha} }
\end{equation*}

\begin{equation*}
\inference[PI-SIDE ]{\context \synth{S}{A} & \synth{TODO}{A} & \contextcons{x : A} \synth{B}{\mathbf{type}} }
{\context \synth{\Pi x : \{S \; T\}. \ B}{\mathbf{type^c}} }
\end{equation*}

\begin{equation*}
\inference[TYPE-APP ]{\context \synth{A}{\Pi x : B. \ K} & \context \tycheck{M}{B} }
{\context \synth{A M}{\subst{M}{x}{K}} }
\end{equation*}

\begin{equation*}
\inference[APP ]{ \context \synth{M}{\Pi x : A. \ B} & \context \tycheck{N}{A} }
{\context \synth{M N}{\subst{M}{x}{N}} }
\end{equation*}

\begin{equation*}
\inference[APP-SC ]{ \context \synth{M}{\Pi x : \{S \; T\}. \ B} & \context \tycheck{N}{A} }
{\context \synth{M N}{\subst{M}{x}{TODO}} }
\end{equation*}

\begin{equation*}
\inference[LAMANN ]{\context \synth{A}{\mathbf{type}} & \contextcons{x : A} \synth{M}{B}  }
{\context \synth{\lambda x : A. \ M}{\Pi x : A. \ B} }
\end{equation*}

\begin{equation*}
\inference[LAM ]{\contextcons{x : A} \synth{M}{B}  }
{\context \tycheck{\lambda x. \ M}{\Pi x : A. \ B} }
\end{equation*}
\caption{Bidirectional typing rules for LFSC}
\end{figure}
#+end_export

For brevity we simply use \vdash instead of \vdash_\Sigma when its meaning is obvious.\footnote{what is the right word here?}
#+begin_export latex
\begin{figure}[h!]
\begin{equation*}
\inference[IFMARKED ]{\context \synth{S}{A} & \synth{T_1}{B} & \synth{T_2}{B}}
{\context \synth{\mathbf{ifmarked} \; n \; S T_1 T_2}{B} }
\end{equation*}
\begin{equation*}
\inference[MARKVAR ]{\context \synth{S}{A}}
{\context \synth{\mathbf{markvar} \; n \; S}{A} }
\end{equation*}
\begin{equation*}
\inference[Let ]{\context \synth{S}{A} & \contextcons{x: A} \synth{T}{B} }
{\context \synth{\mathbf{let} \; x \; S \; T}{B} }
\end{equation*}
\begin{equation*}
\inference[DO ]{\context \synth{S}{A} & \context \synth{T}{B} }
{\context \synth{\mathbf{do} \; S \; T}{B} }
\end{equation*}
\caption{Typing rules for sideeffects}
\end{figure}
#+end_export
#+begin_export latex
\begin{figure}[h!]
\begin{multline*}
\inference[PROGAPP ]{ \context \synth{f}{\{x_1: A_1, \dots, x_1 : A : A_n \} . S} \\
& \forall i \in \{ 1, \dots, n \}. (\context \tycheck{T_i}{A_i})\\
& \contextcons{x_1 : A_1,\dots, x_n : A_n} \synth{S}{B} }
{\context \synth{f (T_1, \dots, T_n)}{B}}
\end{multline*}
\begin{equation*}
\inference[MATCH ]{\context \synth{S}{A} & \forall i \in \{ 1, \dots, n\}.(\context \synth{P_i}{A} & \contextcons{\mathbf{ctx}(P_i)} \synth{T_i}{B} ) }
{\context \synth{\mathbf{match} \; S \; (P_1, T_1) \dots (P_n,T_n)}{B} }
\end{equation*}
\begin{equation*}
\inference[IFEQ ]{\context \synth{S_1}{A} & \context \synth{S_2}{A} & \context \synth{T_1}{B} & \context \synth{T_2}{B} }
{\context \synth{\mathbf{ifeq} \; S_1 \; S_2 \; T_1 \; T_2}{B} }
\end{equation*}
\begin{equation*}
\inference[FAIL ]{\context \synth{A}{\mathbf{type}}}
{\context \synth{\mathbf{fail} \; A}{A} }
\end{equation*}
\caption{Typing rules for compound sideconditions}
\end{figure}
#+end_export

#+begin_export latex
\begin{figure}[h!]
\begin{equation*}
\inference[INT ]{ }
{\context \synth{n}{\mathbf{integer}}}
\end{equation*}
\begin{equation*}
\inference[NEG ]{\context \synth{S}{\mathbf{integer}} }
{\context \synth{- S}{\mathbf{integer}}}
\end{equation*}
\begin{equation*}
\inference[Z-TO-Q ]{\context \synth{S}{\mathbf{integer}} }
{\context \synth{\mathbf{ztoq} \; S}{\mathbf{rational}}}
\end{equation*}
\begin{equation*}
\inference[BINOP ]{\context \synth{S}{\mathbf{integer}} & \synth{T}{\mathbf{integer}} }
{\context \synth{S \oplus T}{\mathbf{integer}} }\oplus \in \{+, *, / \}
\end{equation*}
\begin{equation*}
\inference[IFNEG ]{\context \synth{S}{\mathbf{integer}} & \context \synth{T}{A} & \context \synth{U}{A} }
{\context \synth{\mathbf{ifneg} \; S \; T \; U}{A} }
\end{equation*}
\begin{equation*}
\inference[IFZERO ]{\context \synth{S}{\mathbf{integer}} & \context \synth{T}{A} & \context \synth{U}{A} }
{\context \synth{\mathbf{ifzero} \; S \; T \; U}{A} }
\end{equation*}
\caption{Typing rules for numerical sideconditions}
\end{figure}
#+end_export

#+begin_export latex
\begin{figure}[h!]
\begin{equation*}
\inference[CST-O ]{ }
{ \judge{1}{c}{c}{1} }
\qquad
\inference[VAR-O ]{ }
{ \judge{1}{x}{x}{1} }
\qquad
\inference[NUM-O ]{ }
{ \judge{1}{r}{r}{1} }
\end{equation*}

\begin{equation*}
\inference[CST-APP ]{ \forall i \in \{ 1, \dots, n\} . (\judge{i}{S_i}{S_i'}{i+1}) }
{ \judge{1}{(c \; S_1 \dots S_n)}{(c \; S_1' \dots S_n')}{n+1} }
\end{equation*}

\begin{equation*}
\inference[LET-O ]{ \judge{1}{S}{S'}{2} & \judge{2}{\subst{S'}{x}{T}}{T'}{3} }
{ \judge{1}{(\mathbf{let}\; x \; S \; T)}{T'}{3} }
\qquad
\inference[DO-O ]{ \judge{1}{S}{S'}{2} & \judge{2}{T}{T'}{3} }
{ \judge{1}{(\mathbf{do}\; S \; T)}{T'}{3} }
\end{equation*}
\begin{equation*}
\inference[IFEQUAL-T ]{ \judge{1}{S_1}{S_1'}{2} & \judge{2}{S_2}{S_2'}{3} & S_1' \equiv_{\beta\eta} S_2' & \judge{3}{T_1}{T_2'}{4} }
{ \judge{1}{(\mathbf{ifequal}\; S_1 \; S_2 \; T_1 \; T_2)}{T_2'}{4} }
\end{equation*}
\begin{equation*}
\inference[IFEQUAL-F ]{ \judge{1}{S_1}{S_1'}{2} & \judge{2}{S_2}{S_2'}{3} & S_1' \not\equiv_{\beta\eta} S_2' & \judge{3}{T_1}{T_2'}{4} }
{ \judge{1}{(\mathbf{ifequal}\; S_1 \; S_2 \; T_1 \; T_2)}{T_2'}{4} }
\end{equation*}

\begin{equation*}
\inference[MATCH-O ]{
\judge{1}{S}{(c \; S_1 \dots S_m)}{2}
& \exists i. P_i = (c x_1 \dots x_m)
& \judge{2}{\lbrack S_1'/x_1,\dots, S_m/x_1 \rbrack T_i}{T'}{3} }
{ \judge{1}{(\mathbf{match} \; S \; (P_1 T_1) \dots (P_n T_n) )}{T'}{3} }
\end{equation*}
\begin{multline*}
\inference[FUN-APP ]{
\forall i \in \{ 1, \dots, n\}. (\Delta \vdash \judge{i}{S_i}{S_i'}{i+1})\\
& (f (x_1 : A_1 \dots x_n : A_n) : B = T) \in \Delta
& \Delta \vdash \judge{n+1}{\lbrack S_1'/x_1, \dots S_n'/x_n \rbrack T }{T'}{n+2}
}
{ \judge{1}{(f \; S_1 \dots S_n)}{T'}{n+2} }
\end{multline*}

\begin{equation*}
\inference[BINOP-O ]{\judge{1}{S}{r_1}{2} & \judge{2}{T}{r_2}{3} & r = r_1 \oplus r_2 }
{\judge{1}{S \oplus T}{r}{3} }\oplus \in \{+, *, / \}
\end{equation*}

\begin{equation*}
\inference[NEG-O ]{\judge{1}{S}{r}{2} }
{\judge{1}{- S}{r}{2} }
\qquad
\inference[ZTOQ-O ]{\judge{1}{S}{z}{2} & r = z/z }
{\judge{1}{\mathbf{ztoq}\; S}{r}{2} }
\end{equation*}

\begin{equation*}
\inference[IFNEG--T ]{ \judge{1}{S}{r}{2} &  r < 0 & \judge{2}{T}{T'}{3} }
{ \judge{1}{(\mathbf{ifneg} \; S \; T \; U)}{T'}{3} }
\qquad
\inference[IFNEG--F ]{ \judge{1}{S}{r}{2} &  r \ge 0 & \judge{2}{U}{U'}{3} }
{ \judge{1}{(\mathbf{ifneg} \; S \; T \; U)}{U'}{3} }
\end{equation*}
\begin{equation*}
\inference[IFZERO--T ]{ \judge{1}{S}{r}{2} &  r = 0 & \judge{2}{T}{T'}{3} }
{ \judge{1}{(\mathbf{ifzero} \; S \; T \; U)}{T'}{3} }
\qquad
\inference[IFZERO--F ]{ \judge{1}{S}{r}{2} &  r \ne 0 & \judge{2}{U}{U'}{3} }
{ \judge{1}{(\mathbf{ifzero} \; S \; T \; U)}{U'}{3} }
\end{equation*}

\begin{equation*}
\inference[IFMARKED--T ]{ \judge{1}{S}{x}{2} &  \sigma_2 x & \judge{2}{T}{T'}{3} }
{ \judge{1}{(\mathbf{ifmarked} \; S \; T \; U)}{T'}{3} }
\qquad
\inference[IFMARKED--F ]{ \judge{1}{S}{x}{2} &  \neg \sigma_2 x & \judge{2}{U}{U'}{3} }
{ \judge{1}{(\mathbf{ifmarked} \; S \; T \; U)}{U'}{3} }
\end{equation*}
\begin{equation*}
\inference[MARKVAR-O ]{ \judge{1}{S}{x}{2} }
{ \judge{1}{(\mathbf{markvar} \; S)}{x}{2}\lbrack x \mapsto \neg \sigma_2 x \rbrack }
\end{equation*}
\caption{Operational semantics for side conditions}
\end{figure}
#+end_export
Errors are not included in the operational semantics. Errors might occur when *fail* is evaluated, a match does not match any pattern, if *markvar* or *ifmarked* does not evaluate to a variable, if division by 0 is reached or a free identifier is found.
