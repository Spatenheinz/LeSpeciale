In LFSC there are two constructs we use to keep track of variables and constants. We have signatures, and contexts. Signatures are used to assign kinds and types to constants, and thus defing the formal system on which terms are judged.
Contexts are used to assign types to variables.
we write them as in Figure \ref{fig:context} and use we use \Sigma, \Sigma' to denote the concatenation of the two signatures \Sigma and \Sigma' and similarly for contexts.

#+caption: Syntactical categories of LFSC
#+label: fig:context
\begin{figure}[h!]
\begin{align*}
\Sigma \; ::=& \; \lra{} \; \mid \; \Sigma,a : K \; \mid \; \Sigma,c : A \\
\Gamma \; ::=& \; \lra{} \; \mid \; \Gamma, x: A\\
\end{align*}
\end{figure}

The typesystem of LFSC is syntax directed meaning there exists only a single typing rule for each syntactical object.
We achieve this by bidirectional typing.
That means instead of stating that an expression must have a type,
we can either construct a type from it (called inference)
or we can check that an expression has a type.
All assertions has one of the following forms.
#+begin_export latex
\begin{align*}
\Sigma \ \checked & \qquad (\Sigma\ \text{is a valid signature})\\
\vdash_\Sigma \ \Gamma & \qquad (\Gamma\ \text{is a valid context in} \ \Sigma)\\
\Gamma \ \vdash_\Sigma K & \qquad (K \ \text{is a kind in \(\Gamma\) and \(\Sigma\)})\\
\Gamma \ \vdash_\Sigma M \Leftarrow A & \qquad (M \ \text{can be checked to have type \(A\) in \(\Gamma\) and \(\Sigma\)})\\
\Gamma \ \vdash_\Sigma M \Rightarrow A & \qquad (M \ \text{can be infered to have type \(A\) in \(\Gamma\) and \(\Sigma\)})\\
\end{align*}
#+end_export

The validity of signatures is depicted in Figure \ref{fig:validsig}.
The empty signature is valid. The concatenation of singatures are valid if,
\Sigma is valid and the constant is not present in the context. For /KIND-SIG/ $K$ must be valid in \Sigma, while
for /TYPE-SIG/ we require the $A$ can be inferred to have type $K$.
#+caption: Valid signatures
#+label: fig:validsig
\begin{figure}[h!]
\begin{equation*}
\inference[EMPTY-SIG ]{}
{\lra{} \ \checked}
\end{equation*}
\begin{equation*}
\inference[KIND-SIG ]{\Sigma \ \checked & \vdashs K & a \notin dom(\Sigma)}
{\Sigma, a: K \ \checked}
\end{equation*}
\begin{equation*}
\inference[TYPE-SIG ]{\Sigma \ \checked & \vdashs A \Rightarrow K & c \notin dom(\Sigma)}
{\Sigma, c: A \ \checked}
\end{equation*}
\end{figure}

An empty context is valid under \Sigma given the validity of \Sigma. For concatenation $x$ must not occur in \Sigma but can
occur in \Gamma, and again we require that $A$ can be inferred as any kind, as seen in Figure \ref{fig:validctx}
#+caption: Valid contexts
#+label: fig:validctx
\begin{figure}[h!]
\begin{equation*}
\inference[EMPTY-CTX ]{\Sigma \ \checked}
{\vdashs \lra{}}
\end{equation*}
\begin{equation*}
\inference[TYPE-CTX ]{\vdashs \Gamma & \Gamma \vdashs A \Rightarrow K & x \notin dom(\Sigma)}
{\vdashs \Gamma, x : A}
\end{equation*}
\end{figure}
