With the signature and contexts we can define the typing rules for LFSC.
For the entire section we brevitate $\vdash_\Sigma$ to $\vdash$ and it is assumed $\Sigma$ is valid.

*** Lookup
Figure \ref{fig:tylookup} describes type inference with respect to the signatures and contexts. That is, they contain all rules that where variables or constants are inferred wrt. the signature and context.
Given that \Gamma and \Sigma is valid, we can infer the build in types *type* and *type^c* to be *kind*.
Notice here that *type* and *type^c* are kinds which describes types, whereas *kind* describes kinds.
Notice further that *kind* cannot be inferred and thus ensures that no type contains itself hence providing a consistent metalogic.
constants can be inferred either as a kind or a type respcetively if they appear in the signature, whereas object level variables must occur in the context.
#+begin_export latex
\begin{figure}[h!]
\begin{equation*}
\inference[TYPE ]{\vdash \Gamma}
{\Gamma \vdash \mathbf{type} \Rightarrow \mathbf{kind}}
\qquad
\inference[TYPEc ]{\vdash \Gamma}
{\Gamma \vdash \mathbf{type}^c \Rightarrow \mathbf{kind}}
\end{equation*}
\begin{equation*}
\inference[MPZ ]{\vdash \Gamma}
{\Gamma \vdash \mathbf{mpz} \Rightarrow \mathbf{type}}
\qquad
\inference[MPQ ]{\vdash \Gamma}
{\Gamma \vdash \mathbf{mpq} \Rightarrow \mathbf{type}}
\end{equation*}

\begin{equation*}
\inference[LOOKUP-CTX ]{\vdash \Gamma & x: A \in \Gamma}
{\Gamma \vdash \synth{x}{A} }
\end{equation*}

\begin{equation*}
\inference[LOOKUP-KIND-SIG ]{\vdash \Gamma & a: K \in \Sigma}
{\Gamma \vdash \synth{a}{K} }
\qquad
\inference[LOOKUP-TYPE-SIG ]{\vdash \Gamma & c: A \in \Sigma}
{\Gamma \vdash \synth{c}{A} }
\end{equation*}
\caption{Typing rules for looking up types.}
\label{fig:tylookup}
\end{figure}
#+end_export

*** Terms and Types
Figure \ref{fig:tylfsc} describes the bidirectional typing of LFSC.

- /ANN/ states that given object /M/ can be checked to have type /A/, then the annotation can be inferred to type /A/.
- /LAM-ANN/ states that a bound variable /x/ has type /A/ in /M/ can be inferred as a \(\Pi x : A. B\), given that /A/ is *type* and that /M/ can be inferred as /B/ with \(x : A\) added to the environment.
- Lambda abstractions, /LAM/, is the only type that we cannot directly infer, but instead must be checked to be a function type. A lambda a is valid function type if the body /M/ can be inferred as /B/ with \(x : A\) added to the context.
- Both /TYPE-APP/ and /APP/ states that the function point (left construct) must be a function type and that the argument (right construct) can be checked to be the type of domain of the function type, then an application can be inferred as the substitution of the operand with the /x/ in the construct describing the range of the function.
- /APP-SC/ is where the type system of LFSC differs from that of LF. If the type of $M$ is a function type, where the range itself is a function type with a side condition as domain, then $N$ will be checked to have type $A$ and the sidecondition $S$ is evaluated by its operations semantics, and must result in $O$.
#+begin_export latex
\begin{figure}[h!]
\begin{equation*}
\inference[Z ]{\vdash \Gamma}
{\Gamma \vdash z \Rightarrow \mathbf{mpz}}
\qquad
\inference[Q ]{\vdash \Gamma}
{\Gamma q \Rightarrow \mathbf{mpq}}
\end{equation*}
\begin{equation*}
\inference[ANN ]{\context \tycheck{M}{A} }
{\context \synth{M : A}{A} }
\end{equation*}

\begin{equation*}
\inference[PI ]{\context \tycheck{A}{\mathbf{type}} & \contextcons{x : A} \synth{C}{\alpha} & \alpha \in \{ \mathbf{type}, \mathbf{type^c}, \mathbf{kind} \}  }
{\context \synth{\Pi x : A. C}{\alpha} }
\end{equation*}

\begin{equation*}
\inference[PI-SC ]{\context \synth{S}{\mathbf{type}} & \synth{M}{\mathbf{type}} & \context \synth{B}{\mathbf{type}} }
{\context \synth{\Pi x : \{S \; M\}. \ B}{\mathbf{type^c}} }
\end{equation*}

\begin{equation*}
\inference[TYPE-APP ]{\context \synth{A}{\Pi x : B. \ K} & \context \tycheck{M}{B} }
{\context \synth{A \; M}{\subst{M}{x}{K}} }
\end{equation*}

\begin{equation*}
\inference[APP ]{ \context \synth{M}{\Pi x : A. \ B} & \context \tycheck{N}{A} }
{\context \synth{M \; N}{\subst{N}{x}{M}} }
\end{equation*}

\begin{equation*}
\inference[APP-SC ]{ \context \synth{M}{\Pi x_1 : A. (\Pi x_2 : \{S \; O\}. B)} & \context \tycheck{N}{A} & |\Sigma| \vdash \epsilon;\subst{M}{x}{S} \downarrow \subst{M}{x}{O};\sigma}
{\context \synth{M \; N}{\subst{N}{x_1}{B}} }
\end{equation*}

\begin{equation*}
\inference[LAM-ANN ]{\context \synth{A}{\mathbf{type}} & \contextcons{x : A} \synth{M}{B}  }
{\context \synth{\lambda x : A. \ M}{\Pi x : A. \ B} }
\end{equation*}

\begin{equation*}
\inference[LAM ]{\contextcons{x : A} \synth{M}{B}  }
{\context \tycheck{\lambda x. \ M}{\Pi x : A. \ B} }
\end{equation*}
\caption{Bidirectional typing rules for LFSC}
\label{fig:tylfsc}
\medskip
\small
Here $\subst{M}{x}{K}$, denotes the substitution of $M$ with $x$ in $K$. The letter $C$ is either a type or a kind.
$|\Sigma|$ denotes all sidecondition function definitions in $\Sigma$.
\end{figure}
#+end_export


*** Side conditions
For easier readability we split the side condition language into three subcategories:
1. *numerical* side conditions focused around numerical values.
2. *side effects* side conditions can update the state in evaluation.
3. *compound* side conditions are construct that dont fall into the other categories.

For numerical sideconditions the rules are straight forward. They are represented for *integer* in \ref{fig:tynum} but work similarly for rational, except for Z-TO-Q, which as the name suggest requires $S$ to be of type *integer*.
/IFNEG/ and /IFZERO/ are branching constructs where the condition must be one of the two number types and the branches must have the same type.
#+begin_export latex
\begin{figure}[h!]
\begin{equation*}
\inference[INT ]{ }
{\context \synth{n}{\mathbf{integer}}}
\qquad
\inference[NEG ]{\context \synth{S}{\mathbf{integer}} }
{\context \synth{- S}{\mathbf{integer}}}
\qquad
\inference[Z-TO-Q ]{\context \synth{S}{\mathbf{integer}} }
{\context \synth{\mathbf{ztoq} \; S}{\mathbf{rational}}}
\end{equation*}
\begin{equation*}
\inference[BINOP ]{\context \synth{S}{\mathbf{integer}} & \synth{T}{\mathbf{integer}} }
{\context \synth{S \oplus T}{\mathbf{integer}} }\oplus \in \{+, *, / \}
\end{equation*}
\begin{equation*}
\inference[IFNEG ]{\context \synth{S}{\mathbf{integer}} & \context \synth{T}{A} & \context \synth{U}{A} }
{\context \synth{\mathbf{ifneg} \; S \; T \; U}{A} }
\end{equation*}
\begin{equation*}
\inference[IFZERO ]{\context \synth{S}{\mathbf{integer}} & \context \synth{T}{A} & \context \synth{U}{A} }
{\context \synth{\mathbf{ifzero} \; S \; T \; U}{A} }
\end{equation*}
\caption{Typing rules for numerical sideconditions}
\label{fig:tynum}
\end{figure}
#+end_export

For side effects rules we have that /LET-SC/ works as its counter part, and /DO/ is mere syntactical sugar for /LET/ but with the binding of a variable.
/MARKVAR/ will simply return the type the inner sidecondition and /IFMARKED/ will check the "marked" sidecondition /S/ and check that the two branches have the same type, resulting in the type of the branches.
 #+begin_export latex
\begin{figure}[h!]
\begin{equation*}
\inference[IFMARKED ]{\context \synth{S}{A} & \synth{T}{B} & \synth{U}{B}}
{\context \synth{\mathbf{ifmarked} \; n \; S \; T \; U}{B} }
\end{equation*}
\begin{equation*}
\inference[MARKVAR ]{\context \synth{S}{A}}
{\context \synth{\mathbf{markvar} \; n \; S}{A} }
\end{equation*}
\begin{equation*}
\inference[Let ]{\context \synth{S}{A} & \contextcons{x: A} \synth{T}{B} }
{\context \synth{\mathbf{let} \; x \; S \; T}{B} }
\end{equation*}
\begin{equation*}
\inference[DO ]{\context \synth{S}{A} & \context \synth{T}{B} }
{\context \synth{\mathbf{do} \; S \; T}{B} }
\end{equation*}
\caption{Typing rules for sideeffects}
\end{figure}
#+end_export


Compound sideconditions may be a *fail*, described by the /FAIL/ rule, which simply typechecks the inner value.
The reason *fail* must take an argument is that we have no polymorphic type $\forall \alpha. \alpha \rightarrow \alpha$ under dependent types.
For /IFEQ/ \(S_1\) and \(S_2\) must have the same type and the branches
\(T_1\) and \(T_2\) must equally have the same type.
Match statement work similar to other functional languages and
given the scrutinee \(S\) can be inferred as \(A\) then for all match cases \(P_i\) must also be inferreable as /A/, whilst all branches \(T_i\) must be inferreable to the same type /B/. \(\mathbf{ctx}(P_i)\) describes the context created from \(P_i\). concretely
\(\mathbf{ctx}(P_i) = \lra{}, x_1 : A_1, x_2 : A_2, \dots, x_n : A_n\), when \(P_i = c x_1 \; x_2 \; \dots \; x_n\)
For applications the function point must not be a dependent function.

#+begin_export latex
\begin{figure}[h!]
\begin{equation*}
\inference[SCAPP ]{\context \synth{S}{\Pi x : A. B} & \context \synth{T}{C} & x \notin FV(B) }
{\context \synth{S \; T}{B}}
\end{equation*}
\begin{equation*}
\inference[MATCH ]{\context \synth{S}{A} & \forall i \in \{ 1, \dots, n\}.(\context \synth{P_i}{A} & \contextcons{\mathbf{ctx}(P_i)} \synth{T_i}{B} ) }
{\context \synth{\mathbf{match} \; S \; (P_1, T_1) \dots (P_n,T_n)}{B} }
\end{equation*}
\begin{equation*}
\inference[IFEQ ]{\context \synth{S_1}{A} & \context \synth{S_2}{A} & \context \synth{T_1}{B} & \context \synth{T_2}{B} }
{\context \synth{\mathbf{ifequal} \; S_1 \; S_2 \; T_1 \; T_2}{B} }
\end{equation*}
\begin{equation*}
\inference[FAIL ]{\context \synth{A}{\mathbf{type}}}
{\context \synth{\mathbf{fail} \; A}{A} }
\end{equation*}
\caption{Typing rules for compound sideconditions}
\end{figure}
#+end_export

