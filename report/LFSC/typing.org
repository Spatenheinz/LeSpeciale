Figure \ref{fig:tylookup} describes type inference with respect to the signatures and contexts.
Given that \Gamma and \Sigma is valid, we can infer the build in types *type* and *type^c* to be *kind*.
Notice here that *type* and *type^c* are kinds which describes types often denoted as * in the literature, whereas *kind* describes kinds. constants can be inferred either as a kind or a type respcetively if they appear in the signature, whereas object level variables must occur in the context.
#+begin_export latex
\begin{figure}[h!]
\begin{equation*}
\inference[TYPE ]{\vdash \Gamma}
{\context \mathbf{type} \Rightarrow \mathbf{kind}}
\qquad
\inference[TYPEc ]{\vdash \Gamma}
{\context \mathbf{type}^c \Rightarrow \mathbf{kind}}
\end{equation*}

\begin{equation*}
\inference[LOOKUP-CTX ]{\vdash \Gamma & x: A \in \Gamma}
{\context \synth{x}{A} }
\end{equation*}

\begin{equation*}
\inference[LOOKUP-KIND-SIG ]{\vdash \Gamma & a: K \in \Sigma}
{\context \synth{a}{K} }
\qquad
\inference[LOOKUP-TYPE-SIG ]{\vdash \Gamma & c: A \in \Sigma}
{\context \synth{c}{A} }
\end{equation*}
\caption{Typing rules for looking up types.}
\label{fig:tylookup}
\end{figure}
#+end_export

Figure \ref{fig:tylfsc} describes the bidirectional typing of LFSC.
For brevity we simply use \vdash instead of \vdash_\Sigma as it is assumed \Sigma is valid.
/ANN/ states that given object /M/ can be checked to have type /A/ then the annotation can be inferred to type /A/.

Both /TYPE-APP/ and /APP/ states that the rator (left construct) must be a function type and that the operand (right construct) can be checked to be the type of domain of the function type, then an application can be inferred as the substitution of the operand with the /x/ in the construct describing the range of the function.
/APP-SC/
/LAMANN/ states that a bound variable /x/ has type /A/ in /M/ can be inferred as a \(\Pi x : A. B\) given that /A/ is a *type* and that /M/ can be inferred as /B/ with \(x : A\) added to the environment.
Lambda abstractions is the only type that we cannot directly infer but instead must be checked to be a function type. A lambda is valid function type if the body /M/ can be inferred as /B/ with \(x : A\) added to the context.
concrete integers and rationals must trivially be their respective types.
#+begin_export latex
\begin{figure}[h!]
\begin{equation*}
\inference[ANN ]{\context \tycheck{M}{A} }
{\context \synth{M : A}{A} }
\end{equation*}

\begin{equation*}
\inference[PI ]{\context \tycheck{A}{\mathbf{type}} & \contextcons{x : A} \synth{B}{\alpha} & \alpha \in \{ \mathbf{type}, \mathbf{type^c}, \mathbf{kind} \}  }
{\context \synth{\Pi x : A. \ B}{\alpha} }
\end{equation*}

\begin{equation*}
\inference[PI-SIDE ]{\context \synth{S}{A} & \synth{TODO}{A} & \contextcons{x : A} \synth{B}{\mathbf{type}} }
{\context \synth{\Pi x : \{S \; T\}. \ B}{\mathbf{type^c}} }
\end{equation*}

\begin{equation*}
\inference[TYPE-APP ]{\context \synth{A}{\Pi x : B. \ K} & \context \tycheck{M}{B} }
{\context \synth{A M}{\subst{M}{x}{K}} }
\end{equation*}

\begin{equation*}
\inference[APP ]{ \context \synth{M}{\Pi x : A. \ B} & \context \tycheck{N}{A} }
{\context \synth{M N}{\subst{M}{x}{N}} }
\end{equation*}

\begin{equation*}
\inference[APP-SC ]{ \context \synth{M}{\Pi x : \{S \; T\}. \ B} & \context \tycheck{N}{A} }
{\context \synth{M N}{\subst{M}{x}{TODO}} }
\end{equation*}

\begin{equation*}
\inference[LAMANN ]{\context \synth{A}{\mathbf{type}} & \contextcons{x : A} \synth{M}{B}  }
{\context \synth{\lambda x : A. \ M}{\Pi x : A. \ B} }
\end{equation*}

\begin{equation*}
\inference[LAM ]{\contextcons{x : A} \synth{M}{B}  }
{\context \tycheck{\lambda x. \ M}{\Pi x : A. \ B} }
\end{equation*}
\caption{Bidirectional typing rules for LFSC}
\label{fig:tylfsc}
\end{figure}
#+end_export

#+begin_export latex
\begin{figure}[h!]
\begin{equation*}
\inference[IFMARKED ]{\context \synth{S}{A} & \synth{T_1}{B} & \synth{T_2}{B}}
{\context \synth{\mathbf{ifmarked} \; n \; S T_1 T_2}{B} }
\end{equation*}
\begin{equation*}
\inference[MARKVAR ]{\context \synth{S}{A}}
{\context \synth{\mathbf{markvar} \; n \; S}{A} }
\end{equation*}
\begin{equation*}
\inference[Let ]{\context \synth{S}{A} & \contextcons{x: A} \synth{T}{B} }
{\context \synth{\mathbf{let} \; x \; S \; T}{B} }
\end{equation*}
\begin{equation*}
\inference[DO ]{\context \synth{S}{A} & \context \synth{T}{B} }
{\context \synth{\mathbf{do} \; S \; T}{B} }
\end{equation*}
\caption{Typing rules for sideeffects}
\end{figure}
#+end_export
#+begin_export latex
\begin{figure}[h!]
\begin{multline*}
\inference[PROGAPP ]{ \context \synth{f}{\{x_1: A_1, \dots, x_1 : A : A_n \} . S} \\
& \forall i \in \{ 1, \dots, n \}. (\context \tycheck{T_i}{A_i})\\
& \contextcons{x_1 : A_1,\dots, x_n : A_n} \synth{S}{B} }
{\context \synth{f (T_1, \dots, T_n)}{B}}
\end{multline*}
\begin{equation*}
\inference[MATCH ]{\context \synth{S}{A} & \forall i \in \{ 1, \dots, n\}.(\context \synth{P_i}{A} & \contextcons{\mathbf{ctx}(P_i)} \synth{T_i}{B} ) }
{\context \synth{\mathbf{match} \; S \; (P_1, T_1) \dots (P_n,T_n)}{B} }
\end{equation*}
\begin{equation*}
\inference[IFEQ ]{\context \synth{S_1}{A} & \context \synth{S_2}{A} & \context \synth{T_1}{B} & \context \synth{T_2}{B} }
{\context \synth{\mathbf{ifeq} \; S_1 \; S_2 \; T_1 \; T_2}{B} }
\end{equation*}
\begin{equation*}
\inference[FAIL ]{\context \synth{A}{\mathbf{type}}}
{\context \synth{\mathbf{fail} \; A}{A} }
\end{equation*}
\caption{Typing rules for compound sideconditions}
\end{figure}
#+end_export

#+begin_export latex
\begin{figure}[h!]
\begin{equation*}
\inference[INT ]{ }
{\context \synth{n}{\mathbf{integer}}}
\end{equation*}
\begin{equation*}
\inference[NEG ]{\context \synth{S}{\mathbf{integer}} }
{\context \synth{- S}{\mathbf{integer}}}
\end{equation*}
\begin{equation*}
\inference[Z-TO-Q ]{\context \synth{S}{\mathbf{integer}} }
{\context \synth{\mathbf{ztoq} \; S}{\mathbf{rational}}}
\end{equation*}
\begin{equation*}
\inference[BINOP ]{\context \synth{S}{\mathbf{integer}} & \synth{T}{\mathbf{integer}} }
{\context \synth{S \oplus T}{\mathbf{integer}} }\oplus \in \{+, *, / \}
\end{equation*}
\begin{equation*}
\inference[IFNEG ]{\context \synth{S}{\mathbf{integer}} & \context \synth{T}{A} & \context \synth{U}{A} }
{\context \synth{\mathbf{ifneg} \; S \; T \; U}{A} }
\end{equation*}
\begin{equation*}
\inference[IFZERO ]{\context \synth{S}{\mathbf{integer}} & \context \synth{T}{A} & \context \synth{U}{A} }
{\context \synth{\mathbf{ifzero} \; S \; T \; U}{A} }
\end{equation*}
\caption{Typing rules for numerical sideconditions}
\end{figure}
#+end_export
