#+begin_export latex
\begin{figure}[h!]
\begin{equation*}
\inference[TYPE ]{\vdash \Gamma}
{\context \mathbf{type} \Rightarrow \mathbf{kind}}
\qquad
\inference[TYPEc ]{\vdash \Gamma}
{\context \mathbf{type}^c \Rightarrow \mathbf{kind}}
\end{equation*}

\begin{equation*}
\inference[LOOKUP-CTX ]{\vdash \Gamma & x: A \in \Gamma}
{\context \synth{x}{A} }
\end{equation*}

\begin{equation*}
\inference[LOOKUP-KIND-SIG ]{\vdash \Gamma & a: K \in \Sigma}
{\context \synth{a}{K} }
\qquad
\inference[LOOKUP-TYPE-SIG ]{\vdash \Gamma & c: A \in \Sigma}
{\context \synth{c}{A} }
\end{equation*}
\caption{Typing rules for looking up types.}
\end{figure}
#+end_export

#+begin_export latex
\begin{figure}[h!]
\begin{equation*}
\inference[ANN ]{\context \tycheck{M}{A} }
{\context \synth{M : A}{A} }
\end{equation*}

\begin{equation*}
\inference[PI ]{\context \tycheck{A}{\mathbf{type}} & \contextcons{x : A} \synth{B}{\alpha} & \alpha \in \{ \mathbf{type}, \mathbf{type^c}, \mathbf{kind} \}  }
{\context \synth{\Pi x : A. \ B}{\alpha} }
\end{equation*}

\begin{equation*}
\inference[PI-SIDE ]{\context \synth{S}{A} & \synth{TODO}{A} & \contextcons{x : A} \synth{B}{\mathbf{type}} }
{\context \synth{\Pi x : \{S \; T\}. \ B}{\mathbf{type^c}} }
\end{equation*}

\begin{equation*}
\inference[TYPE-APP ]{\context \synth{A}{\Pi x : B. \ K} & \context \tycheck{M}{B} }
{\context \synth{A M}{\subst{M}{x}{K}} }
\end{equation*}

\begin{equation*}
\inference[APP ]{ \context \synth{M}{\Pi x : A. \ B} & \context \tycheck{N}{A} }
{\context \synth{M N}{\subst{M}{x}{N}} }
\end{equation*}

\begin{equation*}
\inference[APP-SC ]{ \context \synth{M}{\Pi x : \{S \; T\}. \ B} & \context \tycheck{N}{A} }
{\context \synth{M N}{\subst{M}{x}{TODO}} }
\end{equation*}

\begin{equation*}
\inference[LAMANN ]{\context \synth{A}{\mathbf{type}} & \contextcons{x : A} \synth{M}{B}  }
{\context \synth{\lambda x : A. \ M}{\Pi x : A. \ B} }
\end{equation*}

\begin{equation*}
\inference[LAM ]{\contextcons{x : A} \synth{M}{B}  }
{\context \tycheck{\lambda x. \ M}{\Pi x : A. \ B} }
\end{equation*}
\caption{Bidirectional typing rules for LFSC}
\end{figure}
#+end_export

For brevity we simply use \vdash instead of \vdash_\Sigma when its meaning is obvious.\footnote{what is the right word here?}
#+begin_export latex
\begin{figure}[h!]
\begin{equation*}
\inference[IFMARKED ]{\context \synth{S}{A} & \synth{T_1}{B} & \synth{T_2}{B}}
{\context \synth{\mathbf{ifmarked} \; n \; S T_1 T_2}{B} }
\end{equation*}
\begin{equation*}
\inference[MARKVAR ]{\context \synth{S}{A}}
{\context \synth{\mathbf{markvar} \; n \; S}{A} }
\end{equation*}
\begin{equation*}
\inference[Let ]{\context \synth{S}{A} & \contextcons{x: A} \synth{T}{B} }
{\context \synth{\mathbf{let} \; x \; S \; T}{B} }
\end{equation*}
\begin{equation*}
\inference[DO ]{\context \synth{S}{A} & \context \synth{T}{B} }
{\context \synth{\mathbf{do} \; S \; T}{B} }
\end{equation*}
\caption{Typing rules for sideeffects}
\end{figure}
#+end_export
#+begin_export latex
\begin{figure}[h!]
\begin{multline*}
\inference[PROGAPP ]{ \context \synth{f}{\{x_1: A_1, \dots, x_1 : A : A_n \} . S} \\
& \forall i \in \{ 1, \dots, n \}. (\context \tycheck{T_i}{A_i})\\
& \contextcons{x_1 : A_1,\dots, x_n : A_n} \synth{S}{B} }
{\context \synth{f (T_1, \dots, T_n)}{B}}
\end{multline*}
\begin{equation*}
\inference[MATCH ]{\context \synth{S}{A} & \forall i \in \{ 1, \dots, n\}.(\context \synth{P_i}{A} & \contextcons{\mathbf{ctx}(P_i)} \synth{T_i}{B} ) }
{\context \synth{\mathbf{match} \; S \; (P_1, T_1) \dots (P_n,T_n)}{B} }
\end{equation*}
\begin{equation*}
\inference[IFEQ ]{\context \synth{S_1}{A} & \context \synth{S_2}{A} & \context \synth{T_1}{B} & \context \synth{T_2}{B} }
{\context \synth{\mathbf{ifeq} \; S_1 \; S_2 \; T_1 \; T_2}{B} }
\end{equation*}
\begin{equation*}
\inference[FAIL ]{\context \synth{A}{\mathbf{type}}}
{\context \synth{\mathbf{fail} \; A}{A} }
\end{equation*}
\caption{Typing rules for compound sideconditions}
\end{figure}
#+end_export

#+begin_export latex
\begin{figure}[h!]
\begin{equation*}
\inference[INT ]{ }
{\context \synth{n}{\mathbf{integer}}}
\end{equation*}
\begin{equation*}
\inference[NEG ]{\context \synth{S}{\mathbf{integer}} }
{\context \synth{- S}{\mathbf{integer}}}
\end{equation*}
\begin{equation*}
\inference[Z-TO-Q ]{\context \synth{S}{\mathbf{integer}} }
{\context \synth{\mathbf{ztoq} \; S}{\mathbf{rational}}}
\end{equation*}
\begin{equation*}
\inference[BINOP ]{\context \synth{S}{\mathbf{integer}} & \synth{T}{\mathbf{integer}} }
{\context \synth{S \oplus T}{\mathbf{integer}} }\oplus \in \{+, *, / \}
\end{equation*}
\begin{equation*}
\inference[IFNEG ]{\context \synth{S}{\mathbf{integer}} & \context \synth{T}{A} & \context \synth{U}{A} }
{\context \synth{\mathbf{ifneg} \; S \; T \; U}{A} }
\end{equation*}
\begin{equation*}
\inference[IFZERO ]{\context \synth{S}{\mathbf{integer}} & \context \synth{T}{A} & \context \synth{U}{A} }
{\context \synth{\mathbf{ifzero} \; S \; T \; U}{A} }
\end{equation*}
\caption{Typing rules for numerical sideconditions}
\end{figure}
#+end_export
