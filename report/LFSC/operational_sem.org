The operational semantics is show in Figure [[fig:operational]].
The operational semantics are under the judgement of
\(\Delta \vdash \sigma \judge{1}{S}{T}{n} \), where \Delta describes all program definitions \(\sigma_1\) and \(\sigma_n\), describes states mapping symbols to markings. The \Delta is elided in all cases where it is unused.
Errors are not included in the operational semantics. Errors might occur when *fail* is evaluated,
a scrutinee does not match any pattern,
a *markvar* or *ifmarked* does not evaluate to a variable or division by 0.
/CST-O/, /VAR-O/ and /NUM-O/ simply evaluate to itself and the store is unchanged.
/CST-APP/ applies a constant to n sideconditions, update the store with respect to all of them and the resulting value is the constant applied to each updated /S'/.
/LET-O/ and /DO-O/ evaluates /S/ and then evaluates /T/ with the updated store and in the case of /LET-O/ by substituting occurences of /x/ in T.
the two rules /IFEQUAL-T/ and /IFEQUAL/ describes a standard semantic for equality checks. Two terms \(S_1'\) and \(S_2'\) are considered equivalent by syntactical equivalence.
Match constructs evaluate the scrutinee and matches the result
with one of the patterns.
If a pattern matches then the given branch is evaluated.
/FUN-APP/ refers to the application of a sidecondition program.
/f/ must be a program in \Delta and all arguments are evaluated and then results are substituted into the body of the program T and it is evaluated.
/BINOP-O/ and /NEG-O/ works similar to any other language.
/ZTOQ-O/ evaluate S to an integer and then make the rational z/z.
/IFNEG/ and /IFZERO/ rules are very similar, based on the evaluation of S, either branch /T/ or branch /U/ is evaluated.
/IFMARKED/ is again similar however the branching depends on the marking of variable /x/ in the store.
/MARKVAR-O/ is the only rule that can update the store.
/n/ is the flag that need to be swapped. The language support 32 flags, corresponding to a 32 bit integer where each bit defines a flag.
#+caption: Operational semantics for side conditions
#+label: fig:operational
\begin{figure}[h!]
\begin{equation*}
\inference[CST-O ]{ }
{ \judge{1}{c}{c}{1} }
\qquad
\inference[VAR-O ]{ }
{ \judge{1}{x}{x}{1} }
\qquad
\inference[NUM-O ]{ }
{ \judge{1}{r}{r}{1} }
\end{equation*}

\begin{equation*}
\inference[CST-APP ]{ \forall i \in \{ 1, \dots, n\} . (\judge{i}{S_i}{S_i'}{i+1}) }
{ \judge{1}{(c \; S_1 \dots S_n)}{(c \; S_1' \dots S_n')}{n+1} }
\end{equation*}

\begin{equation*}
\inference[LET-O ]{ \judge{1}{S}{S'}{2} & \judge{2}{\subst{S'}{x}{T}}{T'}{3} }
{ \judge{1}{(\mathbf{let}\; x \; S \; T)}{T'}{3} }
\qquad
\inference[DO-O ]{ \judge{1}{S}{S'}{2} & \judge{2}{T}{T'}{3} }
{ \judge{1}{(\mathbf{do}\; S \; T)}{T'}{3} }
\end{equation*}
\begin{equation*}
\inference[IFEQUAL-T ]{ \judge{1}{S_1}{S_1'}{2} & \judge{2}{S_2}{S_2'}{3} & S_1' \equiv_{\beta\eta} S_2' & \judge{3}{T_1}{T_2'}{4} }
{ \judge{1}{(\mathbf{ifequal}\; S_1 \; S_2 \; T_1 \; T_2)}{T_2'}{4} }
\end{equation*}
\begin{equation*}
\inference[IFEQUAL-F ]{ \judge{1}{S_1}{S_1'}{2} & \judge{2}{S_2}{S_2'}{3} & S_1' \not\equiv_{\beta\eta} S_2' & \judge{3}{T_1}{T_2'}{4} }
{ \judge{1}{(\mathbf{ifequal}\; S_1 \; S_2 \; T_1 \; T_2)}{T_2'}{4} }
\end{equation*}

\begin{equation*}
\inference[MATCH-O ]{
\judge{1}{S}{(c \; S_1 \dots S_m)}{2}
& \exists i. P_i = (c x_1 \dots x_m)
& \judge{2}{\lbrack S_1'/x_1,\dots, S_m/x_1 \rbrack T_i}{T'}{3} }
{ \judge{1}{(\mathbf{match} \; S \; (P_1 T_1) \dots (P_n T_n) )}{T'}{3} }
\end{equation*}
\begin{multline*}
\inference[FUN-APP ]{
\forall i \in \{ 1, \dots, n\}. (\Delta \vdash \judge{i}{S_i}{S_i'}{i+1})\\
& (f (x_1 : A_1 \dots x_n : A_n) : B = T) \in \Delta
& \Delta \vdash \judge{n+1}{\lbrack S_1'/x_1, \dots S_n'/x_n \rbrack T }{T'}{n+2}
}
{ \judge{1}{(f \; S_1 \dots S_n)}{T'}{n+2} }
\end{multline*}

\begin{equation*}
\inference[BINOP-O ]{\judge{1}{S}{r_1}{2} & \judge{2}{T}{r_2}{3} & r = r_1 \oplus r_2 }
{\judge{1}{S \oplus T}{r}{3} }\oplus \in \{+, *, / \}
\end{equation*}

\begin{equation*}
\inference[NEG-O ]{\judge{1}{S}{r}{2} }
{\judge{1}{- S}{r}{2} }
\qquad
\inference[ZTOQ-O ]{\judge{1}{S}{z}{2} & r = z/z }
{\judge{1}{\mathbf{ztoq}\; S}{r}{2} }
\end{equation*}

\begin{equation*}
\inference[IFNEG--T ]{ \judge{1}{S}{r}{2} &  r < 0 & \judge{2}{T}{T'}{3} }
{ \judge{1}{(\mathbf{ifneg} \; S \; T \; U)}{T'}{3} }
\qquad
\inference[IFNEG--F ]{ \judge{1}{S}{r}{2} &  r \ge 0 & \judge{2}{U}{U'}{3} }
{ \judge{1}{(\mathbf{ifneg} \; S \; T \; U)}{U'}{3} }
\end{equation*}
\begin{equation*}
\inference[IFZERO--T ]{ \judge{1}{S}{r}{2} &  r = 0 & \judge{2}{T}{T'}{3} }
{ \judge{1}{(\mathbf{ifzero} \; S \; T \; U)}{T'}{3} }
\qquad
\inference[IFZERO--F ]{ \judge{1}{S}{r}{2} &  r \ne 0 & \judge{2}{U}{U'}{3} }
{ \judge{1}{(\mathbf{ifzero} \; S \; T \; U)}{U'}{3} }
\end{equation*}

\begin{equation*}
\inference[IFMARKED--T ]{ \judge{1}{S}{x}{2} &  \sigma_2 x & \judge{2}{T}{T'}{3} }
{ \judge{1}{(\mathbf{ifmarked} \; S \; T \; U)}{T'}{3} }
\qquad
\inference[IFMARKED--F ]{ \judge{1}{S}{x}{2} &  \neg \sigma_2 x & \judge{2}{U}{U'}{3} }
{ \judge{1}{(\mathbf{ifmarked} \; S \; T \; U)}{U'}{3} }
\end{equation*}
\begin{equation*}
\inference[MARKVAR-O ]{ \judge{1}{S}{x}{2} }
{ \judge{1}{(\mathbf{markvar} \; S)}{x}{2}\lbrack x \mapsto \neg \sigma_2 x \rbrack }
\end{equation*}
\end{figure}
