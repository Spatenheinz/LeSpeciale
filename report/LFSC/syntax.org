Figure \ref{fig:lfscsyntax} shows the 5 categories of the LFSC language.
At its core LFSC is a typed lambda calculus and it consists of terms/objects, types, and kinds. The last two categories are patterns and side conditions.

Terms are denoted by /M/, /N/, and /O/ and are used as syntactical entities, proofs, or inference rules in a logic.
Types are denoted by /A/ and /B/ and are used for the classification of terms and to describe judgments and assertions.
Kinds are denoted by K and are used to classify types.

#+begin_export latex
\begin{figure}[h!]
\begin{align*}
K \; ::=& \; \mathbf{type} \; | \; \mathbf{type}^c \; | \; \mathbf{kind} \; | \; \pilf{x}{A}{K} \; | \; \mathbf{int} \; | \mathbf{rational} \\
A,B \; ::=& \; a \; | \; A \; M \; | \; \pilf{x}{\{S \; M\}}{A} \; | \; \pilf{x}{A}{B} \\
M,N,O \; ::=& \; x \; | \; c \; | \; z \; | \; q \; | \; * \; | \; M : A \; | \; \mathbf{let} \; x \; M \; N \; | \; \lambda x . M \; | \; \lambda x : A . M \; | \; M \; N \\
P \; ::=& \; c \; | \; c \; x_1 \dots x_n \\
S,T,U \; ::=& \; x \; | c \; | \; - S \; | \; S \oplus S \; | \; c \; S_1 \dots S_n \; | \; \mathbf{let} \; x \; S \; T \; | \; \mathbf{markvar} \; S \; |\\
& \; \mathbf{ifequal} \; S_1 \; S_2 \; T \; U \; | \; \mathbf{match} \; S \; (P_1 \; T_1) \; \dots \; (P_n \; T_n) \; | \; \mathbf{fail} \; S \; |\\
& \; \mathbf{ifneg} \; S \; T \; U \; | \mathbf{ifzero} \; S \; T \; U \; | \mathbf{ifmarked} \; S \; T \; U \; |  \; \mathbf{ztoq} \; S\\
\oplus \; \in& \; \{+, /, *\cdot\}
\end{align*}
\caption{Syntactical categories of LFSC}
\label{fig:lfscsyntax}
\end{figure}
#+end_export

We use $x$ to be a metavariable ranging over the set of variables that might occur in terms, $c$ to denote constants in terms, i.e. free variables. $a$ will range over constants in types.
Side conditions are denoted by /S/ and /T/ and /U/.
Patterns describe patterns in side condition match cases and are denoted by /P/.
Primitives and keywords of the side condition language are represented in *bold*. $z$ and $q$ are meta symbols representing integers and rationals.
$*$ represents a hole, which can be filled with any term in the type-checking process.
Both \Pi and \lambda are abstractions that bind the variable in the body.
type annotations are given by $:$ and $\{S \; M\}$ is a pair.
