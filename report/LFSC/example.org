In this Section we give an example of how LFSC can be used to construct proofs.
We do so, by explaining a proof that \(P \wedge \neg P \) is unsatisfiable.
The proof can be encoded by the following commands:

#+caption: Unsatisfiability proof of $P \wedge \neg P$ in LFSC
#+name: fig:proof
#+begin_src none -n
(define cvc.p (var 0 Bool))
(check
(# a0 (holds (and cvc.p (and (not cvc.p) true)))
(: (holds false)
(resolution _  _  _
(and_elim _  _  1 a0)
(and_elim _  _  0 a0) ff cvc.p))))
#+end_src
The program first defines a variable ~cvc.p~ which is an application of the function ~var~ which is used to define free constants under SMT-Lib, it is specifically charaterized by a unique number and a sort.
This makes ~cvc.p~ unique.
~cvc.p~ describes the /P/ in the formula above.

Then the proof is constructed by a check command.
We first define ~a0~ stating that \(P \wedge (\neg P \wedge \top)\) holds.
The reason ~true~ is also included, is because SMT-lib considers applications as n-ary functions and these will be represented as
a null-terminated curried form of higher order application.
Specifically ~and~ is defined by:
#+begin_src
(declare apply (! t1 term (! t2 term term)))
(declare f_and term)
(define and (# t1 term (# t2 term (apply (apply f_and t1) t2))))
#+end_src

the body of the check is then an annotation stating that
line 5-7 should have the type ~holds false~.
We notice that there are quite a number of holes. these will get filled out as we go.

~resolution~ and ~and_elim~ are declared as follows:
#+begin_src
(declare resolution (! c1 term
                    (! c2 term
                    (! c term
                    (! p1 (holds c1)
                    (! p2 (holds c2)
                    (! pol flag
                    (! l term
                    (! r (^ (sc_resolution c1 c2 pol l) c) (holds c))))))))))
(declare and_elim (! f1 term
                  (! f2 term
                  (! n mpz
                  (! p (holds f1)
                  (! r (^ (nary_extract f_and f1 n) f2)  (holds f2)))))))

#+end_src
We can from these declarations see that the 3 holes on line 5 in Figure \ref{fig:proog}, should match parameters ~c1, c2, c~, these occur later in the type and can therefore be "derived" the latter arguments.
similarly for ~and_elim~ the hole used for argument ~f1~ will be filled by argument ~p~ because the types must match.

Since the fourth argument of the ~and_elim~ applications are ~a0~, we can syntactically compare ~a0~ and ~(holds f1)~, letting ~f1~ = ~(and cvc.p (and (not cvc.p) true))~.
Notice here that both applications of ~and_elim~ is provided with 4 arguments. But by the typing rules the inner sidecondition will be evaluated.
Hence when all types are checked ~nary_extract~ is run.
~nary_extract~ is defined as:
#+begin_src
(function nary_extract ((f term) (t term) (n mpz)) term
  (match t
    ((apply t1 t2)
      (mp_ifzero n
        (getarg f t1)
        (nary_extract f t2 (mp_add n (mp_neg 1))))))
)
#+end_src
It will extract the ~n~-th element of an ~f~ application in ~t~.
so when nary_extract is called with ~f_and~, ~f1~ = ~(and cvc.p (and (not cvc.p) true))~ and ~1~, then by beta reduction we have:
~f1~ = ~(apply (apply f_and cvc.p) (and (not cvc.p) true))~.
The only branch of ~nary_extract~ matches this scrutinee and we check if n is 0.
Since it is not we recursively call extract.
In the next iteration we get:
~t~ = ~(apply (apply f_and (not cvc.p)) true))~,
now ~n~ is also 0 and we call ~getarg~ defined as follows:
#+begin_src
(function getarg ((f term) (t term)) term
  (match t ((apply t1 t2) (ifequal t1 f t2 (fail term)))))
#+end_src
~t~ now is ~(apply f_and (not cvc.p))~.
Since ~t1~ and ~f~ is both ~f_and~ we therefore get ~(not cvc.p)~ back.
This is then checked agains ~f2~ (in the run case of ~and_elim~) and the body ~(holds f2)~ is then checked.
By similar approch we get ~cvc.p~ from the other application of ~and_elim~.

By now we have established all the arguments to ~resolution~,
~c1~ = ~(not cvc.p)~, ~c2~ = ~cvc.p~, ~c~ is still a hole and ~p1~ and ~p2~ is ~(holds (not cvc.p))~ and ~(holds cvc.p)~ respectively.
and ~sc_resolution~ is evaluated.
#+begin_src
(function sc_resolution
    ((c1 term) (c2 term) (pol flag) (l term)) term
  (nary_elim f_or
    (nary_concat f_or
      (nary_rm_first_or_self f_or
         (nary_intro f_or c1 false)
         (ifequal pol tt l (apply f_not l))
          false)
      (nary_rm_first_or_self f_or
          (nary_intro f_or c2 false)
          (ifequal pol tt (apply f_not l) l)
           false)
    false)
  false))
#+end_src
at the inner most applications we have calls to ~nary_intro~ which lifts a value into ~n~-ary form.
The two calls will turn ~c1~ into ~(or c1 false)~ and vice versa.
~nary_rm_first_or_self~ will then check if the result of ~nary_intro~ is equivalent to the ~ifequal~ call and return the fourth argument ~false~ if that is the case otherwise it will remove the first occurence of ~f_or~.
For the application in line 4, the arguments are ~(or (not cvc.p) false) (apply f_not cvc.p) false~.
The first two arguments are not equivalent and thus we remove the first occurence of ~f_or~ in the first argument.
\beta-reduced the term is ~(apply (apply f_or (not cvc.p)) false)~ hence the result will be ~false~.
For line 5 we equally get ~false~.

~nary_concat~ will then also return ~false~, since the arguments are not ~n~-ary applications.
We can then clearly not eliminate any ~f_or~ from the expression, thus the result becomes ~false~.

We match hole ~f_2~ in ~resolution~ with the result and get ~holds false~ which is equivlaent to the annotated type,
hereby concluding the proof.

From this small example, the takeaway should be that sideconditions can be useful because they allow recursive structure,
meaning we for instance can extract the $n^{th}$ clause of a conjuction, instead of applying conjunction elimination $n$ times.


# apply (apply f_or (not cvc.p)) false
# apply (apply f_or (apply f_not cvc.p)) false
# ...
# let t12 = getarg f t1 => apply f_not cvc.p
# false

# line 5 ===
# (or cvc.p false) cvc.p false
# apply (apply f_or cvc.p) false
# let t12 = getarg f t1 => cvc.p => false

# nary_concat : false
# nanry elim f_or false false = default => null





# and argument for line 5 (or cvc.p false) (cvc.p). Here the two cases are equivalent to


# Although typechecking should be fast, the proofs ma
