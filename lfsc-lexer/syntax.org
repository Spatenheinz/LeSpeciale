#+title: Syntax


toplevel:
  Define
  Declare
  function
  check

! is á´¨

constants can be not enclosed,
other terms might not,


examples:

#+begin_src elisp
(define cvc.c (var 0 Bool))
; this breaks down as follows:
; cvc.c is an identifier
; (...) is a term
; var 0 Bool is a function application var(0)(Bool)
; function application is: (var 0)(Bool)
; Bool is an identifier and thus a valid term
; var 0 is a function application and thus a valid term
; var is an ident and thus valid, same with 0 as it is a constant.
(check
(@ __t1 (= cvc.b cvc.d)
; check takes a term: which @ is (since it is a let expression)
; __t1 is an identifier thats all good. first part of let is a term.
; rest is another let binding which is a valid term.
(define not (# t term (apply f_not t)))
; define takes an indent, then # is a term because it is an ascribed function.
; an ascribed function takes a string t, a type and a term.
#+end_src

#+begin_src
Type ::= ident
     |   typeconstant (mpq, mpz, type, hole)
     |   pi type (depedent) --> !

Term ::= ident
     |   constants (numbers)
     |   Function application
     |   ascription (:)
     |   unascription (\ and lam)
     |   ascribed function (#)

Command ::=
    Declare{var: String, ty: Type},
    Define{var: String, term: Term},
    Opaque{var: String, term: Term},
    DefConst{var: String, decls: Decls, term: Term},
    Check(Term),
    AssCheck{decls: Decls, ty: Term, term: Term},
    ProgDef{args: Vec<(String, Term)>, ty: Term, body: Term},
    Run(TermSC),
#+end_src


we start with check which will check the inner type, without synthesising?

first we have an annotated lambda,
make a new symbol based on this

if \x: A. M, gives that A is of type Type, then we save x := (x, A), we then check the range,
M, we make ! x domain (classifier of range)


S ::= num | var | '('

S ::= let .. ')' | S ')' | S S ')'


* Sideconditions:

<#+begin_src
S ::=
    num | var | '(' S'

S' ::= 'let' .. ')' | S S ')'
--  S ')'
--  do .. ')'
#+end_src
