; (declare sort type)
; (declare Bool sort)

; (declare term type)
; (declare flag type)
; (declare tt flag)
; (declare ff flag)
; (declare f_not term)

; (declare true term)
; (declare false term)

; ; higher-order apply
; (declare apply (! t1 term (! t2 term term)))

; (declare var (! v mpz (! s sort term)))

; (declare holds (! t term type))

; (declare f_or term)
; (function getarg ((f term) (t term)) term
;   (match t ((apply t1 t2) (ifequal t1 f t2 (fail term)))))

; ; Concatenates terms t1 and t2 that are f-applications in n-ary form.
; (function nary_concat ((f term) (t1 term) (t2 term) (null term)) term
;   (match t1
;     ((apply t11 t12)
;       (let t112 (getarg f t11)
;         (apply t11 (nary_concat f t12 t2 null))))
;     (default t2))    ; any non-application term is interpreted as null
; )

; (function nary_elim ((f term) (t term) (null term)) term
;   (match t
;     ((apply t1 t2)
;       ; if null terminated, then we return the head, otherwise not in n-ary form
;       (ifequal t2 null (getarg f t1) t))
;     (default (ifequal t null t (fail term))))
; )

; (function nary_rm_first ((f term) (t term) (l term)) term
;   (match t
;     ((apply t1 t2)  ; otherwise at end, l not found
;       (let t12 (getarg f t1)
;         (ifequal t12 l t2 (apply t1 (nary_rm_first f t2 l))))))
;         ; otherwise not an f-app in n-ary form
; )

; (function nary_rm_first_or_self ((f term) (t term) (l term) (null term)) term
;   (ifequal t l null (nary_rm_first f t l))
; )

; (function nary_intro ((f term) (t term) (null term)) term
;   (match t
;     ((apply t1 t2)
;       (match t1
;         ((apply t11 t12) (ifequal t11 f t (apply (apply f t) null)))
;         (default (apply (apply f t) null))))
;     (default (ifequal t null t (apply (apply f t) null))))
; )

; (function sc_resolution ((c1 term) (c2 term) (pol flag) (l term)) term
;   (nary_elim f_or
;     (nary_concat f_or
;       (nary_rm_first_or_self f_or (nary_intro f_or c1 false) (ifequal pol tt l (apply f_not l)) false)
;       (nary_rm_first_or_self f_or (nary_intro f_or c2 false) (ifequal pol tt (apply f_not l) l) false)
;     false)
;   false)
; )

; Declare("resolution",
;         Pi(Ident(Symbol("term")),
;         Pi(Ident(Symbol("term")),
;         Pi(Ident(Symbol("term")),
;         Pi(App(Ident(Symbol("holds")), Ident(DBI(2))),
;         Pi(App(Ident(Symbol("holds")), Ident(DBI(2))),
;         Pi(Ident(Symbol("flag")), Pi(Ident(Symbol("term")),
;         Pi(
;             SC(App(Symbol("sc_resolution"), [Ident(DBI(6)), Ident(DBI(5)), Ident(DBI(1)), Ident(DBI(0))]),
;             Ident(DBI(4))), App(Ident(Symbol("holds")), Ident(DBI(5))))))))))))
; (declare resolution (! c1 term
;                     (! c2 term
;                     (! c term
;                     (! p1 (holds c1)
;                     (! p2 (holds c2)
;                     (! pol flag
;                     (! l term
;                     (! r (^ (sc_resolution c1 c2 pol l) c) (holds c))))))))))

; (function nary_extract ((f term) (t term) (n mpz)) term
;   (match t
;     ((apply t1 t2)
;       (mp_ifzero n
;         (getarg f t1)
;         (nary_extract f t2 (mp_add n (mp_neg 1))))))
; )

; (declare f_and term)
; (define and (# t1 term (# t2 term (apply (apply f_and t1) t2))))

; (define not (# t term (apply f_not t)))
; (declare and_elim (! f1 term
;                   (! f2 term
;                   (! n mpz
;                   (! p (holds f1)
;                   (! r (^ (nary_extract f_and f1 n) f2)  (holds f2)))))))

(define cvc.p (var 0 Bool))
(check
(# a0 (holds (and cvc.p (and (not cvc.p) true)))
(: (holds false)
(resolution _  _  _
(and_elim _  _  1 a0)
(and_elim _  _  0 a0) ff cvc.p))))